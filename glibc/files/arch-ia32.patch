Sync the i386 and x86_64 headers into one common IA32 set of headers.

The goal is to ensure that any headers produced in a 32-bit or 64-bit build
are not only functionally equivalent, but actually the same in order to avoid
file conflicts.

The only remaining conflict is the bits/syscall.h.  This is dynamically
generated, and so far I've been unable to figure out how to get both
i386 and x86_64 to generate the same file.  We'll need to handle this
in the recipe itself.

Signed-off-by: Mark Hatle <mark.hatle@windriver.com>

Index: git/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h
===================================================================
--- git.orig/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h
+++ git/nptl/sysdeps/unix/sysv/linux/i386/bits/pthreadtypes.h
@@ -1,5 +1,6 @@
 /* Copyright (C) 2002,2003,2004,2005,2006,2007 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -19,16 +20,29 @@
 #ifndef _BITS_PTHREADTYPES_H
 #define _BITS_PTHREADTYPES_H	1
 
-#define __SIZEOF_PTHREAD_ATTR_T 36
-#define __SIZEOF_PTHREAD_MUTEX_T 24
-#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
-#define __SIZEOF_PTHREAD_COND_T 48
-#define __SIZEOF_PTHREAD_COND_COMPAT_T 12
-#define __SIZEOF_PTHREAD_CONDATTR_T 4
-#define __SIZEOF_PTHREAD_RWLOCK_T 32
-#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
-#define __SIZEOF_PTHREAD_BARRIER_T 20
-#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+# define __SIZEOF_PTHREAD_ATTR_T 56
+# define __SIZEOF_PTHREAD_MUTEX_T 40
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 56
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 32
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
 
 
 /* Thread identifiers.  The structure of the attribute type is not
@@ -43,10 +57,18 @@ typedef union
 } pthread_attr_t;
 
 
+#if __WORDSIZE == 64
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+#else
 typedef struct __pthread_internal_slist
 {
   struct __pthread_internal_slist *__next;
 } __pthread_slist_t;
+#endif
 
 
 /* Data structures for mutex handling.  The structure of the attribute
@@ -58,15 +80,24 @@ typedef union
     int __lock;
     unsigned int __count;
     int __owner;
+#if __WORDSIZE == 64
+    unsigned int __nusers;
+#endif
     /* KIND must stay at this position in the structure to maintain
        binary compatibility.  */
     int __kind;
+#if __WORDSIZE == 64
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+#else
     unsigned int __nusers;
     __extension__ union
     {
       int __spins;
       __pthread_slist_t __list;
     };
+#endif
   } __data;
   char __size[__SIZEOF_PTHREAD_MUTEX_T];
   long int __align;
@@ -75,7 +106,7 @@ typedef union
 typedef union
 {
   char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
-  long int __align;
+  int __align;
 } pthread_mutexattr_t;
 
 
@@ -101,7 +132,7 @@ typedef union
 typedef union
 {
   char __size[__SIZEOF_PTHREAD_CONDATTR_T];
-  long int __align;
+  int __align;
 } pthread_condattr_t;
 
 
@@ -118,6 +149,24 @@ typedef int pthread_once_t;
    structure of the attribute type is not exposed on purpose.  */
 typedef union
 {
+# if __WORDSIZE == 64
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+# else
   struct
   {
     int __lock;
@@ -134,6 +183,7 @@ typedef union
     unsigned char __pad2;
     int __writer;
   } __data;
+# endif
   char __size[__SIZEOF_PTHREAD_RWLOCK_T];
   long int __align;
 } pthread_rwlock_t;
@@ -167,7 +217,9 @@ typedef union
 #endif
 
 
+#if __WORDSIZE == 32
 /* Extra attributes for the cleanup functions.  */
-#define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
+# define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
+#endif
 
 #endif	/* bits/pthreadtypes.h */
Index: git/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h
===================================================================
--- git.orig/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h
+++ git/nptl/sysdeps/unix/sysv/linux/i386/bits/semaphore.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -21,8 +21,13 @@
 # error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
 #endif
 
+#include <bits/wordsize.h>
 
-#define __SIZEOF_SEM_T	16
+#if __WORDSIZE == 64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
 
 
 /* Value returned if `sem_open' failed.  */
Index: git/sysdeps/i386/bits/byteswap.h
===================================================================
--- git.orig/sysdeps/i386/bits/byteswap.h
+++ git/sysdeps/i386/bits/byteswap.h
@@ -25,13 +25,14 @@
 #ifndef _BITS_BYTESWAP_H
 #define _BITS_BYTESWAP_H 1
 
+#include <bits/wordsize.h>
+
 /* Swap bytes in 16 bit value.  */
 #define __bswap_constant_16(x) \
      ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
 
-#ifdef __GNUC__
-# if __GNUC__ >= 2
-#  define __bswap_16(x) \
+#if defined __GNUC__ && __GNUC__ >= 2
+# define __bswap_16(x) \
      (__extension__							      \
       ({ register unsigned short int __v, __x = (unsigned short int) (x);     \
 	 if (__builtin_constant_p (__x))				      \
@@ -42,74 +43,62 @@
 		    : "0" (__x)						      \
 		    : "cc");						      \
 	 __v; }))
-# else
+#else
 /* This is better than nothing.  */
-#  define __bswap_16(x) \
+# define __bswap_16(x) \
      (__extension__							      \
-      ({ register unsigned short int __x = (unsigned short int) (x);	      \
+      ({ register unsigned short int __x = (unsigned short int) (x);          \
 	 __bswap_constant_16 (__x); }))
-# endif
-#else
-static __inline unsigned short int
-__bswap_16 (unsigned short int __bsx)
-{
-  return __bswap_constant_16 (__bsx);
-}
 #endif
 
+
 /* Swap bytes in 32 bit value.  */
 #define __bswap_constant_32(x) \
      ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
       (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
 
-#ifdef __GNUC__
-# if __GNUC__ >= 2
+#if defined __GNUC__ && __GNUC__ >= 2
+# if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
+			  || defined __pentiumpro__ || defined __pentium4__   \
+			  || defined __k8__ || defined __athlon__	      \
+			  || defined __k6__ || defined __nocona__	      \
+			  || defined __core2__ || defined __geode__	      \
+			  || defined __amdfam10__)
 /* To swap the bytes in a word the i486 processors and up provide the
    `bswap' opcode.  On i386 we have to use three instructions.  */
-#  if !defined __i486__ && !defined __pentium__ && !defined __pentiumpro__ \
-      && !defined __pentium4__ && !defined __k8__ && !defined __athlon__ \
-      && !defined __k6__ && !defined __nocona__ && !defined __core2__ \
-      && !defined __geode__ && !defined __amdfam10__
-#   define __bswap_32(x)						      \
+#  define __bswap_32(x) \
      (__extension__							      \
       ({ register unsigned int __v, __x = (x);				      \
 	 if (__builtin_constant_p (__x))				      \
 	   __v = __bswap_constant_32 (__x);				      \
 	 else								      \
-	   __asm__ ("rorw $8, %w0;"					      \
-		    "rorl $16, %0;"					      \
-		    "rorw $8, %w0"					      \
-		    : "=r" (__v)					      \
-		    : "0" (__x)						      \
-		    : "cc");						      \
+	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
 	 __v; }))
-#  else
-#   define __bswap_32(x) \
+# else
+#  define __bswap_32(x)							      \
      (__extension__							      \
       ({ register unsigned int __v, __x = (x);				      \
 	 if (__builtin_constant_p (__x))				      \
 	   __v = __bswap_constant_32 (__x);				      \
 	 else								      \
-	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
+	   __asm__ ("rorw $8, %w0;"					      \
+		    "rorl $16, %0;"					      \
+		    "rorw $8, %w0"					      \
+		    : "=r" (__v)					      \
+		    : "0" (__x)						      \
+		    : "cc");						      \
 	 __v; }))
-#  endif
-# else
-#  define __bswap_32(x) \
-     (__extension__							      \
-      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
 # endif
 #else
-static __inline unsigned int
-__bswap_32 (unsigned int __bsx)
-{
-  return __bswap_constant_32 (__bsx);
-}
+# define __bswap_32(x) \
+     (__extension__							      \
+      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
 #endif
 
 
 #if defined __GNUC__ && __GNUC__ >= 2
 /* Swap bytes in 64 bit value.  */
-#define __bswap_constant_64(x) \
+# define __bswap_constant_64(x) \
      ((((x) & 0xff00000000000000ull) >> 56)				      \
       | (((x) & 0x00ff000000000000ull) >> 40)				      \
       | (((x) & 0x0000ff0000000000ull) >> 24)				      \
@@ -119,19 +108,30 @@ __bswap_32 (unsigned int __bsx)
       | (((x) & 0x000000000000ff00ull) << 40)				      \
       | (((x) & 0x00000000000000ffull) << 56))
 
-# define __bswap_64(x) \
+# if __WORDSIZE == 64
+#  define __bswap_64(x) \
      (__extension__							      \
-      ({ union { __extension__ unsigned long long int __ll;		      \
-		 unsigned long int __l[2]; } __w, __r;			      \
-	 if (__builtin_constant_p (x))					      \
-	   __r.__ll = __bswap_constant_64 (x);				      \
+      ({ register unsigned long __v, __x = (x);				      \
+	 if (__builtin_constant_p (__x))				      \
+	   __v = __bswap_constant_64 (__x);				      \
 	 else								      \
-	   {								      \
-	     __w.__ll = (x);						      \
-	     __r.__l[0] = __bswap_32 (__w.__l[1]);			      \
-	     __r.__l[1] = __bswap_32 (__w.__l[0]);			      \
-	   }								      \
+	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
+	 __v; }))
+# else
+#  define __bswap_64(x) \
+     (__extension__                                                           \
+      ({ union { __extension__ unsigned long long int __ll;                   \
+		 unsigned int __l[2]; } __w, __r;                             \
+	 if (__builtin_constant_p (x))                                        \
+	   __r.__ll = __bswap_constant_64 (x);                                \
+	 else                                                                 \
+	   {                                                                  \
+	     __w.__ll = (x);                                                  \
+	     __r.__l[0] = __bswap_32 (__w.__l[1]);                            \
+	     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \
+	   }                                                                  \
 	 __r.__ll; }))
+# endif
 #endif
 
 #endif /* _BITS_BYTESWAP_H */
Index: git/sysdeps/i386/bits/endian.h
===================================================================
--- git.orig/sysdeps/i386/bits/endian.h
+++ git/sysdeps/i386/bits/endian.h
@@ -1,4 +1,4 @@
-/* i386 is little-endian.  */
+/* i386/x86_64 is little-endian.  */
 
 #ifndef _ENDIAN_H
 # error "Never use <bits/endian.h> directly; include <endian.h> instead."
Index: git/sysdeps/i386/bits/huge_vall.h
===================================================================
--- git.orig/sysdeps/i386/bits/huge_vall.h
+++ git/sysdeps/i386/bits/huge_vall.h
@@ -23,12 +23,14 @@
 # error "Never use <bits/huge_vall.h> directly; include <math.h> instead."
 #endif
 
+#include <bits/wordsize.h>
+
 #if __GNUC_PREREQ(3,3)
 # define HUGE_VALL	(__builtin_huge_vall())
-#elif __GNUC_PREREQ(2,96)
+#elif __GNUC_PREREQ(2,96) && __WORDSIZE == 32
 # define HUGE_VALL	(__extension__ 0x1.0p32767L)
 #else
-
+#if __WORDSIZE == 32
 # define __HUGE_VALL_bytes	{ 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }
 
 # define __huge_vall_t	union { unsigned char __c[12]; long double __ld; }
@@ -39,5 +41,7 @@
 static __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
 #  define HUGE_VALL	(__huge_vall.__ld)
 #  endif /* GCC.  */
-
+#else /* __WORDSIZE == 64 */
+# define HUGE_VALL	((long double) HUGE_VAL)
+#endif /* __WORDSIZE */
 #endif /* GCC 2.95 */
Index: git/sysdeps/i386/bits/link.h
===================================================================
--- git.orig/sysdeps/i386/bits/link.h
+++ git/sysdeps/i386/bits/link.h
@@ -21,6 +21,7 @@
 #endif
 
 
+#if __ELF_NATIVE_CLASS == 32
 /* Registers for entry into PLT on IA-32.  */
 typedef struct La_i86_regs
 {
@@ -55,6 +56,74 @@ extern unsigned int la_i86_gnu_pltexit (
 					uintptr_t *__defcook,
 					const La_i86_regs *__inregs,
 					La_i86_retval *__outregs,
-					const char *__symname);
+					const char *symname);
 
 __END_DECLS
+
+#else
+
+/* Registers for entry into PLT on x86-64.  */
+# if __GNUC_PREREQ (4,0)
+typedef float La_x86_64_xmm __attribute__ ((__vector_size__ (16)));
+typedef float La_x86_64_ymm __attribute__ ((__vector_size__ (32)));
+# else
+typedef float La_x86_64_xmm __attribute__ ((__mode__ (__V4SF__)));
+# endif
+
+typedef union
+{
+# if __GNUC_PREREQ (4,0)
+  La_x86_64_ymm ymm[2];
+# endif
+  La_x86_64_xmm xmm[4];
+} La_x86_64_vector __attribute__ ((aligned(16)));
+
+typedef struct La_x86_64_regs
+{
+  uint64_t lr_rdx;
+  uint64_t lr_r8;
+  uint64_t lr_r9;
+  uint64_t lr_rcx;
+  uint64_t lr_rsi;
+  uint64_t lr_rdi;
+  uint64_t lr_rbp;
+  uint64_t lr_rsp;
+  La_x86_64_xmm lr_xmm[8];
+  La_x86_64_vector lr_vector[8];
+} La_x86_64_regs;
+
+/* Return values for calls from PLT on x86-64.  */
+typedef struct La_x86_64_retval
+{
+  uint64_t lrv_rax;
+  uint64_t lrv_rdx;
+  La_x86_64_xmm lrv_xmm0;
+  La_x86_64_xmm lrv_xmm1;
+  long double lrv_st0;
+  long double lrv_st1;
+  La_x86_64_vector lrv_vector0;
+  La_x86_64_vector lrv_vector1;
+} La_x86_64_retval;
+
+
+__BEGIN_DECLS
+
+extern Elf64_Addr la_x86_64_gnu_pltenter (Elf64_Sym *__sym,
+					  unsigned int __ndx,
+					  uintptr_t *__refcook,
+					  uintptr_t *__defcook,
+					  La_x86_64_regs *__regs,
+					  unsigned int *__flags,
+					  const char *__symname,
+					  long int *__framesizep);
+extern unsigned int la_x86_64_gnu_pltexit (Elf64_Sym *__sym,
+					   unsigned int __ndx,
+					   uintptr_t *__refcook,
+					   uintptr_t *__defcook,
+					   const La_x86_64_regs *__inregs,
+					   La_x86_64_retval *__outregs,
+					   const char *__symname);
+
+__END_DECLS
+
+#endif
Index: git/sysdeps/i386/bits/mathdef.h
===================================================================
--- git.orig/sysdeps/i386/bits/mathdef.h
+++ git/sysdeps/i386/bits/mathdef.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000, 2004, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2004, 2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,12 +23,14 @@
 #if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
 # define _MATH_H_MATHDEF	1
 
-# if defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0
-/* When using -mfpmath=sse, values are computed with the precission of the
-   used type.  */
+# include <bits/wordsize.h>
+
+# if __WORDSIZE == 64 || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
+/* The x86-64 architecture computes values with the precission of the
+   used type.  Similarly for -m32 -mfpmath=sse.  */
 typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
-typedef double double_t;	/* `double' expressions are evaluated as
-				   `double'.  */
+typedef double double_t;	/* `double' expressions are evaluated
+				   as `double'.  */
 # else
 /* The ix87 FPUs evaluate all values in the 80 bit floating-point format
    which is also available for the user as `long double'.  Therefore we
Index: git/sysdeps/i386/bits/select.h
===================================================================
--- git.orig/sysdeps/i386/bits/select.h
+++ git/sysdeps/i386/bits/select.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2001, 2011 Free Software Foundation, Inc.
+/* Copyright (C) 1997-1999,2001,2008,2009,2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,12 +20,21 @@
 # error "Never use <bits/select.h> directly; include <sys/select.h> instead."
 #endif
 
+#include <bits/wordsize.h>
+
 
 #if defined __GNUC__ && __GNUC__ >= 2
+
+# if __WORDSIZE == 64
+#  define __FD_ZERO_STOS "stosq"
+# else
+#  define __FD_ZERO_STOS "stosl"
+# endif
+
 # define __FD_ZERO(fdsp) \
   do {									      \
     int __d0, __d1;							      \
-    __asm__ __volatile__ ("cld; rep; stosl"				      \
+    __asm__ __volatile__ ("cld; rep; " __FD_ZERO_STOS			      \
 			  : "=c" (__d0), "=D" (__d1)			      \
 			  : "a" (0), "0" (sizeof (fd_set)		      \
 					  / sizeof (__fd_mask)),	      \
Index: git/sysdeps/i386/bits/setjmp.h
===================================================================
--- git.orig/sysdeps/i386/bits/setjmp.h
+++ git/sysdeps/i386/bits/setjmp.h
@@ -1,5 +1,4 @@
-/* Copyright (C) 1997,1998,2000,2001,2003,2005,2006
-	Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,2000,2001,2002,2003,2005,2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -17,16 +16,24 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-/* Define the machine-dependent type `jmp_buf'.  Intel 386 version.  */
+/* Define the machine-dependent type `jmp_buf'.  i386/x86-64 version.  */
 #ifndef _BITS_SETJMP_H
-#define _BITS_SETJMP_H	1
+#define _BITS_SETJMP_H  1
 
 #if !defined _SETJMP_H && !defined _PTHREAD_H
 # error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
 #endif
 
-#ifndef	_ASM
+#include <bits/wordsize.h>
+
+#ifndef _ASM
+
+# if __WORDSIZE == 64
+typedef long int __jmp_buf[8];
+# else
 typedef int __jmp_buf[6];
+# endif
+
 #endif
 
-#endif	/* bits/setjmp.h */
+#endif  /* bits/setjmp.h */
Index: git/sysdeps/i386/bits/wordsize.h
===================================================================
--- /dev/null
+++ git/sysdeps/i386/bits/wordsize.h
@@ -0,0 +1,8 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __x86_64__
+# define __WORDSIZE	64
+# define __WORDSIZE_COMPAT32	1
+#else
+# define __WORDSIZE	32
+#endif
Index: git/sysdeps/i386/bits/xtitypes.h
===================================================================
--- /dev/null
+++ git/sysdeps/i386/bits/xtitypes.h
@@ -0,0 +1,34 @@
+/* bits/xtitypes.h -- Define some types used by <bits/stropts.h>.  x86-64.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STROPTS_H
+# error "Never include <bits/xtitypes.h> directly; use <stropts.h> instead."
+#endif
+
+#ifndef _BITS_XTITYPES_H
+#define _BITS_XTITYPES_H	1
+
+#include <bits/types.h>
+
+/* This type is used by some structs in <bits/stropts.h>.  */
+typedef __SLONG32_TYPE __t_scalar_t;
+typedef __ULONG32_TYPE __t_uscalar_t;
+
+
+#endif /* bits/xtitypes.h */
Index: git/sysdeps/i386/fpu/bits/fenv.h
===================================================================
--- git.orig/sysdeps/i386/fpu/bits/fenv.h
+++ git/sysdeps/i386/fpu/bits/fenv.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,1999,2000,2001,2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -20,6 +20,8 @@
 # error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
 #endif
 
+#include <bits/wordsize.h>
+
 
 /* Define bits representing the exception.  We use the bit positions
    of the appropriate bits in the FPU control word.  */
@@ -61,8 +63,10 @@ enum
 typedef unsigned short int fexcept_t;
 
 
-/* Type representing floating-point environment.  This function corresponds
-   to the layout of the block written by the `fstenv'.  */
+/* Type representing floating-point environment.  This structure
+   corresponds to the layout of the block written by the `fstenv'
+   instruction and has additional fields for the contents of the MXCSR
+   register as written by the `stmxcsr' instruction.  */
 typedef struct
   {
     unsigned short int __control_word;
@@ -78,6 +82,9 @@ typedef struct
     unsigned int __data_offset;
     unsigned short int __data_selector;
     unsigned short int __unused5;
+#if __WORDSIZE == 64
+    unsigned int __mxcsr;
+#endif
   }
 fenv_t;
 
Index: git/sysdeps/i386/fpu/bits/mathinline.h
===================================================================
--- git.orig/sysdeps/i386/fpu/bits/mathinline.h
+++ git/sysdeps/i386/fpu/bits/mathinline.h
@@ -1,8 +1,9 @@
-/* Inline math functions for i387.
-   Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2003,2004,2006,2007,2009,
+/* Inline math functions for i387/x86-64.
+   Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2006,2007,2009,
    2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
-   Contributed by John C. Bowman <bowman@math.ualberta.ca>, 1995.
+   Contributed by John C. Bowman <bowman@math.ualberta.ca>, 1995. (i387)
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002. (x86-64)
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -23,6 +24,8 @@
 # error "Never use <bits/mathinline.h> directly; include <math.h> instead."
 #endif
 
+#include <bits/wordsize.h>
+
 #ifndef __extern_inline
 # define __MATH_INLINE __inline
 #else
@@ -32,7 +35,7 @@
 
 #if defined __USE_ISOC99 && defined __GNUC__ && __GNUC__ >= 2
 /* GCC 2.97 and up have builtins that actually can be used.  */
-# if !__GNUC_PREREQ (2,97)
+# if __WORDSIZE == 32 && !__GNUC_PREREQ (2,97)
 /* ISO C99 defines some macros to perform unordered comparisons.  The
    ix87 FPU supports this with special opcodes and we should use them.
    These must not be inline functions since we have to be able to handle
@@ -118,7 +121,7 @@
 		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
 	__result; })
 #  endif /* __i686__ */
-# endif	/* GCC 2.97 */
+# endif	/* __WORDSIZE == 32 && GCC 2.97 */
 
 /* The gcc, version 2.7 or below, has problems with all this inlining
    code.  So disable it for this version of the compiler.  */
@@ -127,14 +130,26 @@
 __MATH_INLINE int
 __NTH (__signbitf (float __x))
 {
+#if __WORDSIZE == 32
   __extension__ union { float __f; int __i; } __u = { __f: __x };
   return __u.__i < 0;
+#else
+  int __m;
+  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+  return __m & 0x8;
+#endif
 }
 __MATH_INLINE int
 __NTH (__signbit (double __x))
 {
+#if __WORDSIZE == 32
   __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
   return __u.__i[1] < 0;
+#else
+  int __m;
+  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
+  return __m & 0x80;
+#endif
 }
 __MATH_INLINE int
 __NTH (__signbitl (long double __x))
@@ -148,7 +163,7 @@ __NTH (__signbitl (long double __x))
 
 /* The gcc, version 2.7 or below, has problems with all this inlining
    code.  So disable it for this version of the compiler.  */
-#if __GNUC_PREREQ (2, 8)
+#if __WORDSIZE == 32 && __GNUC_PREREQ (2, 8)
 
 #if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
      && defined __OPTIMIZE__)
@@ -768,4 +783,4 @@ __inline_mathcode2 (__ieee754_atan2, __y
 		    return __value;)
 #endif
 
-#endif /* __GNUC__  */
+#endif /* WORDSIZE == 32 && __GNUC__  */
Index: git/sysdeps/i386/fpu_control.h
===================================================================
--- git.orig/sysdeps/i386/fpu_control.h
+++ git/sysdeps/i386/fpu_control.h
@@ -1,5 +1,5 @@
-/* FPU control word bits.  i387 version.
-   Copyright (C) 1993,1995-1998,2000,2001,2003 Free Software Foundation, Inc.
+/* FPU control word bits.  i387/x86_64 version.
+   Copyright (C) 1993,1995-1998,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Olaf Flebbe.
 
Index: git/sysdeps/i386/i486/bits/string.h
===================================================================
--- git.orig/sysdeps/i386/i486/bits/string.h
+++ git/sysdeps/i386/i486/bits/string.h
@@ -1,4 +1,4 @@
-/* Optimized, inlined string functions.  i486 version.
+/* Optimized, inlined string functions.  i486/x86-64 version.
    Copyright (C) 1997,1998,1999,2000,2001,2002,2003,2004,2007
    	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
@@ -25,10 +25,11 @@
 /* The ix86 processors can access unaligned multi-byte variables.  */
 #define _STRING_ARCH_unaligned	1
 
+#include <bits/wordsize.h>
 
 /* We only provide optimizations if the user selects them and if
    GNU CC is used.  */
-#if !defined __NO_STRING_INLINES && defined __USE_STRING_INLINES \
+#if __WORDSIZE == 32 && !defined __NO_STRING_INLINES && defined __USE_STRING_INLINES \
     && defined __GNUC__ && __GNUC__ >= 2 && !__BOUNDED_POINTERS__
 
 #ifndef __STRING_INLINE
@@ -1972,4 +1973,4 @@ __strstr_g (__const char *__haystack, __
 # undef __STRING_INLINE
 #endif
 
-#endif	/* use string inlines && GNU CC */
+#endif	/* wordsize == 32 && use string inlines && GNU CC */
Index: git/sysdeps/unix/sysv/linux/i386/bits/a.out.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/bits/a.out.h
+++ git/sysdeps/unix/sysv/linux/i386/bits/a.out.h
@@ -1,3 +1,13 @@
 #ifndef __A_OUT_GNU_H__
 # error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
 #endif
+
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+
+/* Signal to users of this header that this architecture really doesn't
+   support a.out binary format.  */
+#define __NO_A_OUT_SUPPORT 1
+
+#endif
Index: git/sysdeps/unix/sysv/linux/i386/bits/environments.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/bits/environments.h
+++ git/sysdeps/unix/sysv/linux/i386/bits/environments.h
@@ -20,6 +20,8 @@
 # error "Never include this file directly.  Use <unistd.h> instead"
 #endif
 
+#include <bits/wordsize.h>
+
 /* This header should define the following symbols under the described
    situations.  A value `1' means that the model is always supported,
    `-1' means it is never supported.  Undefined means it cannot be
@@ -38,14 +40,39 @@
    only for compatibility.
 */
 
+#if __WORDSIZE == 64
+
+/* Environments with 32-bit wide pointers are optionally provided.
+   Therefore following macros aren't defined:
+   # undef _POSIX_V7_ILP32_OFF32
+   # undef _POSIX_V7_ILP32_OFFBIG
+   # undef _POSIX_V6_ILP32_OFF32
+   # undef _POSIX_V6_ILP32_OFFBIG
+   # undef _XBS5_ILP32_OFF32
+   # undef _XBS5_ILP32_OFFBIG
+   and users need to check at runtime.  */
+
+/* We also have no use (for now) for an environment with bigger pointers
+   and offsets.  */
+# define _POSIX_V7_LPBIG_OFFBIG	-1
+# define _POSIX_V6_LPBIG_OFFBIG	-1
+# define _XBS5_LPBIG_OFFBIG	-1
+
+/* By default we have 64-bit wide `long int', pointers and `off_t'.  */
+# define _POSIX_V7_LP64_OFF64	1
+# define _POSIX_V6_LP64_OFF64	1
+# define _XBS5_LP64_OFF64	1
+
+#else /* __WORDSIZE == 32 */
+
 /* By default we have 32-bit wide `int', `long int', pointers and `off_t'
    and all platforms support LFS.  */
-#define _POSIX_V7_ILP32_OFF32	1
-#define _POSIX_V7_ILP32_OFFBIG	1
-#define _POSIX_V6_ILP32_OFF32	1
-#define _POSIX_V6_ILP32_OFFBIG	1
-#define _XBS5_ILP32_OFF32	1
-#define _XBS5_ILP32_OFFBIG	1
+# define _POSIX_V7_ILP32_OFF32	1
+# define _POSIX_V7_ILP32_OFFBIG	1
+# define _POSIX_V6_ILP32_OFF32	1
+# define _POSIX_V6_ILP32_OFFBIG	1
+# define _XBS5_ILP32_OFF32	1
+# define _XBS5_ILP32_OFFBIG	1
 
 /* We optionally provide an environment with the above size but an 64-bit
    side `off_t'.  Therefore we don't define _POSIX_V7_ILP32_OFFBIG.  */
@@ -60,6 +87,8 @@
    # undef _XBS5_LPBIG_OFFBIG
    and sysconf tests for it at runtime.  */
 
+#endif /* __WORDSIZE == 32 */
+
 #define __ILP32_OFF32_CFLAGS	"-m32"
 #define __ILP32_OFFBIG_CFLAGS	"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64"
 #define __ILP32_OFF32_LDFLAGS	"-m32"
Index: git/sysdeps/unix/sysv/linux/i386/bits/fcntl.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/bits/fcntl.h
+++ git/sysdeps/unix/sysv/linux/i386/bits/fcntl.h
@@ -1,5 +1,5 @@
-/* O_*, F_*, FD_* bit values for Linux.
-   Copyright (C) 1995-1998, 2000, 2004, 2006, 2007, 2009, 2010, 2011
+/* O_*, F_*, FD_* bit values for Linux/i386/x86-64.
+   Copyright (C) 1995,1996,1997,1998,2000,2001,2002,2004,2006,2007,2009,2010
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -23,6 +23,7 @@
 #endif
 
 #include <sys/types.h>
+#include <bits/wordsize.h>
 #ifdef __USE_GNU
 # include <bits/uio.h>
 #endif
@@ -65,7 +66,11 @@
 #endif
 
 #ifdef __USE_LARGEFILE64
-# define O_LARGEFILE	0100000
+# if __WORDSIZE == 64
+#  define O_LARGEFILE	0
+# else
+#  define O_LARGEFILE	0100000
+# endif
 #endif
 
 /* Values for the second argument to `fcntl'.  */
@@ -74,18 +79,28 @@
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-#ifndef __USE_FILE_OFFSET64
+#if __WORDSIZE == 64
 # define F_GETLK	5	/* Get record locking info.  */
 # define F_SETLK	6	/* Set record locking info (non-blocking).  */
 # define F_SETLKW	7	/* Set record locking info (blocking).	*/
+/* Not necessary, we always have 64-bit offsets.  */
+# define F_GETLK64	5	/* Get record locking info.  */
+# define F_SETLK64	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	7	/* Set record locking info (blocking).	*/
 #else
-# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
-# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
-# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
-#endif
-#define F_GETLK64	12	/* Get record locking info.  */
-#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
-#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+# ifndef __USE_FILE_OFFSET64
+#  define F_GETLK	5	/* Get record locking info.  */
+#  define F_SETLK	6	/* Set record locking info (non-blocking).  */
+#  define F_SETLKW	7	/* Set record locking info (blocking).	*/
+# else
+#  define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+#  define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+#  define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+# endif
+# define F_GETLK64	12	/* Get record locking info.  */
+# define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+#endif
 
 #if defined __USE_BSD || defined __USE_UNIX98 || defined __USE_XOPEN2K8
 # define F_SETOWN	8	/* Get owner (process receiving SIGIO).  */
Index: git/sysdeps/unix/sysv/linux/i386/bits/mman.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/bits/mman.h
+++ git/sysdeps/unix/sysv/linux/i386/bits/mman.h
@@ -1,5 +1,5 @@
-/* Definitions for POSIX memory map interface.  Linux/i386 version.
-   Copyright (C) 1997,2000,2003,2005,2006,2009,2010,2011
+/* Definitions for POSIX memory map interface.  Linux/i386/x86_64 version.
+   Copyright (C) 1997,2000,2001,2003,2005,2006,2009,2010,2011
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -53,6 +53,7 @@
 # define MAP_FILE	0
 # define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
 # define MAP_ANON	MAP_ANONYMOUS
+# define MAP_32BIT	0x40		/* Only give out 32-bit addresses.  */
 #endif
 
 /* These are Linux-specific.  */
Index: git/sysdeps/unix/sysv/linux/i386/bits/msq.h
===================================================================
--- /dev/null
+++ git/sysdeps/unix/sysv/linux/i386/bits/msq.h
@@ -0,0 +1,83 @@
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+# error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <bits/wordsize.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+#ifdef __USE_GNU
+# define MSG_EXCEPT	020000	/* recv any msg except of specified type */
+#endif
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+/* Structure of record for one message inside the kernel.
+   The type `struct msg' is opaque.  */
+struct msqid_ds
+{
+  struct ipc_perm msg_perm;	/* structure describing operation permission */
+  __time_t msg_stime;		/* time of last msgsnd command */
+#if __WORDSIZE == 32
+  unsigned long int __unused1;
+#endif
+  __time_t msg_rtime;		/* time of last msgrcv command */
+#if __WORDSIZE == 32
+  unsigned long int __unused2;
+#endif
+  __time_t msg_ctime;		/* time of last change */
+#if __WORDSIZE == 32
+  unsigned long int __unused3;
+#endif
+  unsigned long int __msg_cbytes; /* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  unsigned long int __unused4;
+  unsigned long int __unused5;
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* ipcs ctl commands */
+# define MSG_STAT 11
+# define MSG_INFO 12
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgpool;
+    int msgmap;
+    int msgmax;
+    int msgmnb;
+    int msgmni;
+    int msgssz;
+    int msgtql;
+    unsigned short int msgseg;
+  };
+
+#endif /* __USE_MISC */
Index: git/sysdeps/unix/sysv/linux/i386/bits/shm.h
===================================================================
--- /dev/null
+++ git/sysdeps/unix/sysv/linux/i386/bits/shm.h
@@ -0,0 +1,111 @@
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004, 2009
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Permission flag for shmget.  */
+#define SHM_R		0400		/* or S_IRUGO from <linux/stat.h> */
+#define SHM_W		0200		/* or S_IWUGO from <linux/stat.h> */
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+#define SHM_REMAP	040000		/* take-over region on attach */
+#define SHM_EXEC	0100000		/* execution access */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+__BEGIN_DECLS
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+
+/* Type to count number of attaches.  */
+typedef unsigned long int shmatt_t;
+
+/* Data structure describing a shared memory segment.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    size_t shm_segsz;			/* size of segment in bytes */
+    __time_t shm_atime;			/* time of last shmat() */
+#if __WORDSIZE == 32
+    unsigned long int __unused1;
+#endif
+    __time_t shm_dtime;			/* time of last shmdt() */
+#if __WORDSIZE == 32
+    unsigned long int __unused2;
+#endif
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+#if __WORDSIZE == 32
+    unsigned long int __unused3;
+#endif
+    __pid_t shm_cpid;			/* pid of creator */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    unsigned long int __unused4;
+    unsigned long int __unused5;
+  };
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT 	13
+# define SHM_INFO 	14
+
+/* shm_mode upper byte flags */
+# define SHM_DEST	01000	/* segment will be destroyed on last detach */
+# define SHM_LOCKED	02000   /* segment will not be swapped */
+# define SHM_HUGETLB	04000	/* segment is mapped via hugetlb */
+# define SHM_NORESERVE	010000	/* don't check for reservations */
+
+struct	shminfo
+  {
+    unsigned long int shmmax;
+    unsigned long int shmmin;
+    unsigned long int shmmni;
+    unsigned long int shmseg;
+    unsigned long int shmall;
+    unsigned long int __unused1;
+    unsigned long int __unused2;
+    unsigned long int __unused3;
+    unsigned long int __unused4;
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    unsigned long int shm_tot;	/* total allocated shm */
+    unsigned long int shm_rss;	/* total resident shm */
+    unsigned long int shm_swp;	/* total swapped shm */
+    unsigned long int swap_attempts;
+    unsigned long int swap_successes;
+  };
+
+#endif /* __USE_MISC */
+
+__END_DECLS
Index: git/sysdeps/unix/sysv/linux/i386/bits/sigcontext.h
===================================================================
--- /dev/null
+++ git/sysdeps/unix/sysv/linux/i386/bits/sigcontext.h
@@ -0,0 +1,159 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+struct _fpreg
+{
+  unsigned short significand[4];
+  unsigned short exponent;
+};
+
+struct _fpxreg
+{
+  unsigned short significand[4];
+  unsigned short exponent;
+  unsigned short padding[3];
+};
+
+struct _xmmreg
+{
+  __uint32_t	element[4];
+};
+
+
+
+#if __WORDSIZE == 32
+
+struct _fpstate
+{
+  /* Regular FPU environment.  */
+  __uint32_t	cw;
+  __uint32_t		sw;
+  __uint32_t		tag;
+  __uint32_t		ipoff;
+  __uint32_t		cssel;
+  __uint32_t		dataoff;
+  __uint32_t		datasel;
+  struct _fpreg	_st[8];
+  unsigned short status;
+  unsigned short magic;
+
+  /* FXSR FPU environment.  */
+  __uint32_t		_fxsr_env[6];
+  __uint32_t		mxcsr;
+  __uint32_t		reserved;
+  struct _fpxreg	_fxsr_st[8];
+  struct _xmmreg	_xmm[8];
+  __uint32_t		padding[56];
+};
+
+#ifndef sigcontext_struct
+/* Kernel headers before 2.1.1 define a struct sigcontext_struct, but
+   we need sigcontext.  Some packages have come to rely on
+   sigcontext_struct being defined on 32-bit x86, so define this for
+   their benefit.  */
+# define sigcontext_struct sigcontext
+#endif
+
+struct sigcontext
+{
+  unsigned short gs, __gsh;
+  unsigned short fs, __fsh;
+  unsigned short es, __esh;
+  unsigned short ds, __dsh;
+  unsigned long edi;
+  unsigned long esi;
+  unsigned long ebp;
+  unsigned long esp;
+  unsigned long ebx;
+  unsigned long edx;
+  unsigned long ecx;
+  unsigned long eax;
+  unsigned long trapno;
+  unsigned long err;
+  unsigned long eip;
+  unsigned short cs, __csh;
+  unsigned long eflags;
+  unsigned long esp_at_signal;
+  unsigned short ss, __ssh;
+  struct _fpstate * fpstate;
+  unsigned long oldmask;
+  unsigned long cr2;
+};
+
+#else /* __WORDSIZE == 64 */
+
+struct _fpstate
+{
+  /* FPU environment matching the 64-bit FXSAVE layout.  */
+  __uint16_t		cwd;
+  __uint16_t		swd;
+  __uint16_t		ftw;
+  __uint16_t		fop;
+  __uint64_t		rip;
+  __uint64_t		rdp;
+  __uint32_t		mxcsr;
+  __uint32_t		mxcr_mask;
+  struct _fpxreg	_st[8];
+  struct _xmmreg	_xmm[16];
+  __uint32_t		padding[24];
+};
+
+struct sigcontext
+{
+  unsigned long r8;
+  unsigned long r9;
+  unsigned long r10;
+  unsigned long r11;
+  unsigned long r12;
+  unsigned long r13;
+  unsigned long r14;
+  unsigned long r15;
+  unsigned long rdi;
+  unsigned long rsi;
+  unsigned long rbp;
+  unsigned long rbx;
+  unsigned long rdx;
+  unsigned long rax;
+  unsigned long rcx;
+  unsigned long rsp;
+  unsigned long rip;
+  unsigned long eflags;
+  unsigned short cs;
+  unsigned short gs;
+  unsigned short fs;
+  unsigned short __pad0;
+  unsigned long err;
+  unsigned long trapno;
+  unsigned long oldmask;
+  unsigned long cr2;
+  struct _fpstate * fpstate;
+  unsigned long __reserved1 [8];
+};
+
+#endif /* __WORDSIZE == 64 */
+
+#endif /* _BITS_SIGCONTEXT_H */
Index: git/sysdeps/unix/sysv/linux/i386/bits/stat.h
===================================================================
--- /dev/null
+++ git/sysdeps/unix/sysv/linux/i386/bits/stat.h
@@ -0,0 +1,213 @@
+/* Copyright (C) 1999-2003,2009,2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STAT_H
+#define _BITS_STAT_H	1
+
+/* Versions of the `struct stat' data structure.  */
+#define _STAT_VER_KERNEL	0
+
+#if __WORDSIZE == 32
+# define _STAT_VER_SVR4		2
+# define _STAT_VER_LINUX	3
+
+/* i386 versions of the `xmknod' interface.  */
+# define _MKNOD_VER_LINUX	1
+# define _MKNOD_VER_SVR4	2
+# define _MKNOD_VER		_MKNOD_VER_LINUX /* The bits defined below.  */
+#else
+# define _STAT_VER_LINUX	1
+
+/* x86-64 versions of the `xmknod' interface.  */
+# define _MKNOD_VER_LINUX	0
+#endif
+
+#define _STAT_VER		_STAT_VER_LINUX
+
+struct stat
+  {
+    __dev_t st_dev;		/* Device.  */
+#if __WORDSIZE == 32
+    unsigned short int __pad1;
+#endif
+#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File serial number.	*/
+#else
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+#endif
+#if __WORDSIZE == 32
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+#else
+    __nlink_t st_nlink;		/* Link count.  */
+    __mode_t st_mode;		/* File mode.  */
+#endif
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+#if __WORDSIZE == 64
+    int __pad0;
+#endif
+    __dev_t st_rdev;		/* Device number, if device.  */
+#if __WORDSIZE == 32
+    unsigned short int __pad2;
+#endif
+#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+    __off_t st_size;			/* Size of file, in bytes.  */
+#else
+    __off64_t st_size;			/* Size of file, in bytes.  */
+#endif
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+    __blkcnt_t st_blocks;		/* Number 512-byte blocks allocated. */
+#else
+    __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
+#endif
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+#endif
+#if __WORDSIZE == 64
+    long int __unused[3];
+#else
+# ifndef __USE_FILE_OFFSET64
+    unsigned long int __unused4;
+    unsigned long int __unused5;
+# else
+    __ino64_t st_ino;			/* File serial number.	*/
+# endif
+#endif
+  };
+
+#ifdef __USE_LARGEFILE64
+/* Note stat64 has the same shape as stat for x86-64.  */
+struct stat64
+  {
+    __dev_t st_dev;		/* Device.  */
+# if __WORDSIZE == 64
+    __ino64_t st_ino;		/* File serial number.  */
+    __nlink_t st_nlink;		/* Link count.  */
+    __mode_t st_mode;		/* File mode.  */
+# else
+    unsigned int __pad1;
+    __ino_t __st_ino;			/* 32bit file serial number.	*/
+    __mode_t st_mode;			/* File mode.  */
+    __nlink_t st_nlink;			/* Link count.  */
+# endif
+    __uid_t st_uid;		/* User ID of the file's owner.	*/
+    __gid_t st_gid;		/* Group ID of the file's group.*/
+# if __WORDSIZE == 64
+    int __pad0;
+    __dev_t st_rdev;		/* Device number, if device.  */
+    __off_t st_size;		/* Size of file, in bytes.  */
+# else
+    __dev_t st_rdev;			/* Device number, if device.  */
+    unsigned int __pad2;
+    __off64_t st_size;			/* Size of file, in bytes.  */
+# endif
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+    __blkcnt64_t st_blocks;	/* Nr. 512-byte blocks allocated.  */
+# if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+#  define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+#  define st_mtime st_mtim.tv_sec
+#  define st_ctime st_ctim.tv_sec
+# else
+    __time_t st_atime;			/* Time of last access.  */
+    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __time_t st_mtime;			/* Time of last modification.  */
+    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __time_t st_ctime;			/* Time of last status change.  */
+    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+# endif
+# if __WORDSIZE == 64
+    long int __unused[3];
+# else
+    __ino64_t st_ino;			/* File serial number.		*/
+# endif
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define	_STATBUF_ST_BLKSIZE
+#define _STATBUF_ST_RDEV
+/* Nanosecond resolution time values are supported.  */
+#define _STATBUF_ST_NSEC
+
+/* Encoding of the file mode.  */
+
+#define	__S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define	__S_IFDIR	0040000	/* Directory.  */
+#define	__S_IFCHR	0020000	/* Character device.  */
+#define	__S_IFBLK	0060000	/* Block device.  */
+#define	__S_IFREG	0100000	/* Regular file.  */
+#define	__S_IFIFO	0010000	/* FIFO.  */
+#define	__S_IFLNK	0120000	/* Symbolic link.  */
+#define	__S_IFSOCK	0140000	/* Socket.  */
+
+/* POSIX.1b objects.  Note that these macros always evaluate to zero.  But
+   they do it by enforcing the correct use of the macros.  */
+#define __S_TYPEISMQ(buf)  ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSEM(buf) ((buf)->st_mode - (buf)->st_mode)
+#define __S_TYPEISSHM(buf) ((buf)->st_mode - (buf)->st_mode)
+
+/* Protection bits.  */
+
+#define	__S_ISUID	04000	/* Set user ID on execution.  */
+#define	__S_ISGID	02000	/* Set group ID on execution.  */
+#define	__S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define	__S_IREAD	0400	/* Read by owner.  */
+#define	__S_IWRITE	0200	/* Write by owner.  */
+#define	__S_IEXEC	0100	/* Execute by owner.  */
+
+#ifdef __USE_ATFILE
+# define UTIME_NOW	((1l << 30) - 1l)
+# define UTIME_OMIT	((1l << 30) - 2l)
+#endif
+
+#endif	/* bits/stat.h */
Index: git/sysdeps/unix/sysv/linux/i386/bits/wchar.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/bits/wchar.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* wchar_t type related definitions.
-   Copyright (C) 2000 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _BITS_WCHAR_H
-#define _BITS_WCHAR_H	1
-
-#define __WCHAR_MIN	(-2147483647l - 1l)
-#define __WCHAR_MAX	(2147483647l)
-
-#endif	/* bits/wchar.h */
Index: git/sysdeps/unix/sysv/linux/i386/sys/debugreg.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/debugreg.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/debugreg.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,6 +18,7 @@
 
 #ifndef _SYS_DEBUGREG_H
 #define _SYS_DEBUGREG_H	1
+#include <bits/wordsize.h>
 
 /* Indicate the register numbers for a number of the specific
    debug registers.  Registers 0-3 contain the addresses we wish to trap on */
@@ -55,6 +56,7 @@
 #define DR_LEN_1 (0x0)	      /* Settings for data length to trap on */
 #define DR_LEN_2 (0x4)
 #define DR_LEN_4 (0xC)
+#define DR_LEN_8 (0x8)
 
 /* The low byte to the control register determine which registers are
    enabled.  There are 4 fields of two bits.  One bit is "local", meaning
@@ -70,21 +72,16 @@
 #define DR_LOCAL_ENABLE_MASK  (0x55) /* Set  local bits for all 4 regs */
 #define DR_GLOBAL_ENABLE_MASK (0xAA) /* Set global bits for all 4 regs */
 
-/* The second byte to the control register has a few special things.
+/* The second byte to the control register has a few special
+   things.  */
 
-    On the i386, you should set the DR_LOCAL_SLOWDOWN or
-    DR_GLOBAL_SLOWDOWN bits if you want to know exactly which
-    instruction triggered the watchpoint.  Setting these bits causes
-    the processor to run more slowly, but leaving them clear makes it
-    treat watchpoint hits as imprecise exceptions, so you can't
-    reliably determine which instruction caused the hit.
-
-    The i486 and all later IA-32 processors ignore DR_LOCAL_SLOWDOWN
-    and DR_GLOBAL_SLOWDOWN.  They always report the exception
-    precisely, except in some rare cases, which the user can't do
-    anything about.  */
 
-#define DR_CONTROL_RESERVED (0xFC00) /* Reserved by Intel */
+
+#if __WORDSIZE == 64
+# define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00UL) /* Reserved */
+#else
+# define DR_CONTROL_RESERVED (0x00FC00U) /* Reserved */
+#endif
 #define DR_LOCAL_SLOWDOWN   (0x100)  /* Local slow the pipeline */
 #define DR_GLOBAL_SLOWDOWN  (0x200)  /* Global slow the pipeline */
 
Index: git/sysdeps/unix/sysv/linux/i386/sys/epoll.h
===================================================================
--- /dev/null
+++ git/sysdeps/unix/sysv/linux/i386/sys/epoll.h
@@ -0,0 +1,144 @@
+/* Copyright (C) 2002-2008, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_EPOLL_H
+#define	_SYS_EPOLL_H	1
+
+#include <stdint.h>
+#include <sys/types.h>
+
+/* Get __sigset_t.  */
+#include <bits/sigset.h>
+
+#ifndef __sigset_t_defined
+# define __sigset_t_defined
+typedef __sigset_t sigset_t;
+#endif
+
+
+/* Flags to be passed to epoll_create1.  */
+enum
+  {
+    EPOLL_CLOEXEC = 02000000,
+#define EPOLL_CLOEXEC EPOLL_CLOEXEC
+    EPOLL_NONBLOCK = 04000
+#define EPOLL_NONBLOCK EPOLL_NONBLOCK
+  };
+
+
+enum EPOLL_EVENTS
+  {
+    EPOLLIN = 0x001,
+#define EPOLLIN EPOLLIN
+    EPOLLPRI = 0x002,
+#define EPOLLPRI EPOLLPRI
+    EPOLLOUT = 0x004,
+#define EPOLLOUT EPOLLOUT
+    EPOLLRDNORM = 0x040,
+#define EPOLLRDNORM EPOLLRDNORM
+    EPOLLRDBAND = 0x080,
+#define EPOLLRDBAND EPOLLRDBAND
+    EPOLLWRNORM = 0x100,
+#define EPOLLWRNORM EPOLLWRNORM
+    EPOLLWRBAND = 0x200,
+#define EPOLLWRBAND EPOLLWRBAND
+    EPOLLMSG = 0x400,
+#define EPOLLMSG EPOLLMSG
+    EPOLLERR = 0x008,
+#define EPOLLERR EPOLLERR
+    EPOLLHUP = 0x010,
+#define EPOLLHUP EPOLLHUP
+    EPOLLRDHUP = 0x2000,
+#define EPOLLRDHUP EPOLLRDHUP
+    EPOLLONESHOT = (1 << 30),
+#define EPOLLONESHOT EPOLLONESHOT
+    EPOLLET = (1 << 31)
+#define EPOLLET EPOLLET
+  };
+
+
+/* Valid opcodes ( "op" parameter ) to issue to epoll_ctl().  */
+#define EPOLL_CTL_ADD 1	/* Add a file decriptor to the interface.  */
+#define EPOLL_CTL_DEL 2	/* Remove a file decriptor from the interface.  */
+#define EPOLL_CTL_MOD 3	/* Change file decriptor epoll_event structure.  */
+
+
+typedef union epoll_data
+{
+  void *ptr;
+  int fd;
+  uint32_t u32;
+  uint64_t u64;
+} epoll_data_t;
+
+struct epoll_event
+{
+  uint32_t events;	/* Epoll events */
+  epoll_data_t data;	/* User data variable */
+} __attribute__ ((__packed__));
+
+
+__BEGIN_DECLS
+
+/* Creates an epoll instance.  Returns an fd for the new instance.
+   The "size" parameter is a hint specifying the number of file
+   descriptors to be associated with the new instance.  The fd
+   returned by epoll_create() should be closed with close().  */
+extern int epoll_create (int __size) __THROW;
+
+/* Same as epoll_create but with an FLAGS parameter.  The unused SIZE
+   parameter has been dropped.  */
+extern int epoll_create1 (int __flags) __THROW;
+
+
+/* Manipulate an epoll instance "epfd". Returns 0 in case of success,
+   -1 in case of error ( the "errno" variable will contain the
+   specific error code ) The "op" parameter is one of the EPOLL_CTL_*
+   constants defined above. The "fd" parameter is the target of the
+   operation. The "event" parameter describes which events the caller
+   is interested in and any associated user data.  */
+extern int epoll_ctl (int __epfd, int __op, int __fd,
+		      struct epoll_event *__event) __THROW;
+
+
+/* Wait for events on an epoll instance "epfd". Returns the number of
+   triggered events returned in "events" buffer. Or -1 in case of
+   error with the "errno" variable set to the specific error code. The
+   "events" parameter is a buffer that will contain triggered
+   events. The "maxevents" is the maximum number of events to be
+   returned ( usually size of "events" ). The "timeout" parameter
+   specifies the maximum wait time in milliseconds (-1 == infinite).
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_wait (int __epfd, struct epoll_event *__events,
+		       int __maxevents, int __timeout);
+
+
+/* Same as epoll_wait, but the thread's signal mask is temporarily
+   and atomically replaced with the one provided as parameter.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int epoll_pwait (int __epfd, struct epoll_event *__events,
+			int __maxevents, int __timeout,
+			__const __sigset_t *__ss);
+
+__END_DECLS
+
+#endif /* sys/epoll.h */
Index: git/sysdeps/unix/sysv/linux/i386/sys/io.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/io.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/io.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 2000, 2009 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 2000, 2002, 2009 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -89,94 +89,90 @@ static __inline unsigned int
 inl_p (unsigned short int __port)
 {
   unsigned int _v;
-  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v)
-			:"Nd" (__port));
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (__port));
   return _v;
 }
 
 static __inline void
-outb (unsigned char value, unsigned short int __port)
+outb (unsigned char __value, unsigned short int __port)
 {
-  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (__port));
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (__value), "Nd" (__port));
 }
 
 static __inline void
-outb_p (unsigned char value, unsigned short int __port)
+outb_p (unsigned char __value, unsigned short int __port)
 {
-  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (__value),
 			"Nd" (__port));
 }
 
 static __inline void
-outw (unsigned short int value, unsigned short int __port)
+outw (unsigned short int __value, unsigned short int __port)
 {
-  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (__port));
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (__value), "Nd" (__port));
 
 }
 
 static __inline void
-outw_p (unsigned short int value, unsigned short int __port)
+outw_p (unsigned short int __value, unsigned short int __port)
 {
-  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (__value),
 			"Nd" (__port));
 }
 
 static __inline void
-outl (unsigned int value, unsigned short int __port)
+outl (unsigned int __value, unsigned short int __port)
 {
-  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (__port));
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (__value), "Nd" (__port));
 }
 
 static __inline void
-outl_p (unsigned int value, unsigned short int __port)
+outl_p (unsigned int __value, unsigned short int __port)
 {
-  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (__value),
 			"Nd" (__port));
 }
 
 static __inline void
-insb (unsigned short int __port, void *__addr, unsigned long int __count)
+insb (unsigned short int __port, void *addr, unsigned long int __count)
 {
-  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (__addr), "=c" (__count)
-			:"d" (__port), "0" (__addr), "1" (__count));
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr), "=c" (__count)
+			:"d" (__port), "0" (addr), "1" (__count));
 }
 
 static __inline void
-insw (unsigned short int __port, void *__addr, unsigned long int __count)
+insw (unsigned short int __port, void *addr, unsigned long int __count)
 {
-  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (__addr), "=c" (__count)
-			:"d" (__port), "0" (__addr), "1" (__count));
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr), "=c" (__count)
+			:"d" (__port), "0" (addr), "1" (__count));
 }
 
 static __inline void
-insl (unsigned short int __port, void *__addr, unsigned long int __count)
+insl (unsigned short int __port, void *addr, unsigned long int __count)
 {
-  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (__addr), "=c" (__count)
-			:"d" (__port), "0" (__addr), "1" (__count));
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr), "=c" (__count)
+			:"d" (__port), "0" (addr), "1" (__count));
 }
 
 static __inline void
-outsb (unsigned short int __port, const void *__addr,
-       unsigned long int __count)
+outsb (unsigned short int __port, const void *addr, unsigned long int __count)
 {
-  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (__addr), "=c" (__count)
-			:"d" (__port), "0" (__addr), "1" (__count));
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr), "=c" (__count)
+			:"d" (__port), "0" (addr), "1" (__count));
 }
 
 static __inline void
-outsw (unsigned short int __port, const void *__addr,
-       unsigned long int __count)
+outsw (unsigned short int __port, const void *addr, unsigned long int __count)
 {
-  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (__addr), "=c" (__count)
-			:"d" (__port), "0" (__addr), "1" (__count));
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr), "=c" (__count)
+  			:"d" (__port), "0" (addr), "1" (__count));
 }
 
 static __inline void
-outsl (unsigned short int __port, const void *__addr,
-       unsigned long int __count)
+outsl (unsigned short int __port, const void *addr, unsigned long int __count)
 {
-  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (__addr), "=c" (__count)
-			:"d" (__port), "0" (__addr), "1" (__count));
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr), "=c" (__count)
+			:"d" (__port), "0" (addr), "1" (__count));
 }
 
 #endif	/* GNU C */
Index: git/sysdeps/unix/sysv/linux/i386/sys/perm.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/perm.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/perm.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1999 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1999, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
Index: git/sysdeps/unix/sysv/linux/i386/sys/procfs.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/procfs.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/procfs.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -45,6 +45,7 @@ typedef unsigned long elf_greg_t;
 #define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
 
+#if __WORDSIZE == 32
 /* Register set for the floating-point registers.  */
 typedef struct user_fpregs_struct elf_fpregset_t;
 
@@ -52,7 +53,12 @@ typedef struct user_fpregs_struct elf_fp
    the Pentium III SSE registers in addition to the classic
    floating-point stuff.  */
 typedef struct user_fpxregs_struct elf_fpxregset_t;
-
+#else
+/* Register set for the extended floating-point registers.  Includes
+   the Pentium III SSE registers in addition to the classic
+   floating-point stuff.  */
+typedef struct user_fpregs_struct elf_fpregset_t;
+#endif
 
 /* Signal info.  */
 struct elf_siginfo
@@ -98,8 +104,13 @@ struct elf_prpsinfo
     char pr_zomb;			/* Zombie.  */
     char pr_nice;			/* Nice val.  */
     unsigned long int pr_flag;		/* Flags.  */
+#if __WORDSIZE == 32
     unsigned short int pr_uid;
     unsigned short int pr_gid;
+#else
+    unsigned int pr_uid;
+    unsigned int pr_gid;
+#endif
     int pr_pid, pr_ppid, pr_pgrp, pr_sid;
     /* Lots missing */
     char pr_fname[16];			/* Filename of executable.  */
Index: git/sysdeps/unix/sysv/linux/i386/sys/reg.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/reg.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/reg.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -18,26 +18,62 @@
 
 #ifndef _SYS_REG_H
 #define _SYS_REG_H	1
+#include <bits/wordsize.h>
+
+
+#if __WORDSIZE == 64
+/* Index into an array of 8 byte longs returned from ptrace for
+   location of the users' stored general purpose registers.  */
+
+# define R15	0
+# define R14	1
+# define R13	2
+# define R12	3
+# define RBP	4
+# define RBX	5
+# define R11	6
+# define R10	7
+# define R9	8
+# define R8	9
+# define RAX	10
+# define RCX	11
+# define RDX	12
+# define RSI	13
+# define RDI	14
+# define ORIG_RAX 15
+# define RIP	16
+# define CS	17
+# define EFLAGS	18
+# define RSP	19
+# define SS	20
+# define FS_BASE 21
+# define GS_BASE 22
+# define DS	23
+# define ES	24
+# define FS	25
+# define GS	26
+#else
 
 /* Index into an array of 4 byte integers returned from ptrace for
  * location of the users' stored general purpose registers. */
 
-#define EBX 0
-#define ECX 1
-#define EDX 2
-#define ESI 3
-#define EDI 4
-#define EBP 5
-#define EAX 6
-#define DS 7
-#define ES 8
-#define FS 9
-#define GS 10
-#define ORIG_EAX 11
-#define EIP 12
-#define CS  13
-#define EFL 14
-#define UESP 15
-#define SS   16
+# define EBX 0
+# define ECX 1
+# define EDX 2
+# define ESI 3
+# define EDI 4
+# define EBP 5
+# define EAX 6
+# define DS 7
+# define ES 8
+# define FS 9
+# define GS 10
+# define ORIG_EAX 11
+# define EIP 12
+# define CS  13
+# define EFL 14
+# define UESP 15
+# define SS   16
+#endif
 
-#endif	/* _SYS_REG_H */
+#endif
Index: git/sysdeps/unix/sysv/linux/i386/sys/ucontext.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/ucontext.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/ucontext.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,11 +21,128 @@
 
 #include <features.h>
 #include <signal.h>
+#include <bits/wordsize.h>
 
 /* We need the signal context definitions even if they are not used
    included in <signal.h>.  */
 #include <bits/sigcontext.h>
 
+#if __WORDSIZE == 64
+
+/* Type for general register.  */
+typedef long int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	23
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+#ifdef __USE_GNU
+/* Number of each register in the `gregset_t' array.  */
+enum
+{
+  REG_R8 = 0,
+# define REG_R8		REG_R8
+  REG_R9,
+# define REG_R9		REG_R9
+  REG_R10,
+# define REG_R10	REG_R10
+  REG_R11,
+# define REG_R11	REG_R11
+  REG_R12,
+# define REG_R12	REG_R12
+  REG_R13,
+# define REG_R13	REG_R13
+  REG_R14,
+# define REG_R14	REG_R14
+  REG_R15,
+# define REG_R15	REG_R15
+  REG_RDI,
+# define REG_RDI	REG_RDI
+  REG_RSI,
+# define REG_RSI	REG_RSI
+  REG_RBP,
+# define REG_RBP	REG_RBP
+  REG_RBX,
+# define REG_RBX	REG_RBX
+  REG_RDX,
+# define REG_RDX	REG_RDX
+  REG_RAX,
+# define REG_RAX	REG_RAX
+  REG_RCX,
+# define REG_RCX	REG_RCX
+  REG_RSP,
+# define REG_RSP	REG_RSP
+  REG_RIP,
+# define REG_RIP	REG_RIP
+  REG_EFL,
+# define REG_EFL	REG_EFL
+  REG_CSGSFS,		/* Actually short cs, gs, fs, __pad0.  */
+# define REG_CSGSFS	REG_CSGSFS
+  REG_ERR,
+# define REG_ERR	REG_ERR
+  REG_TRAPNO,
+# define REG_TRAPNO	REG_TRAPNO
+  REG_OLDMASK,
+# define REG_OLDMASK	REG_OLDMASK
+  REG_CR2
+# define REG_CR2	REG_CR2
+};
+#endif
+
+struct _libc_fpxreg
+{
+  unsigned short int significand[4];
+  unsigned short int exponent;
+  unsigned short int padding[3];
+};
+
+struct _libc_xmmreg
+{
+  __uint32_t	element[4];
+};
+
+struct _libc_fpstate
+{
+  /* 64-bit FXSAVE format.  */
+  __uint16_t		cwd;
+  __uint16_t		swd;
+  __uint16_t		ftw;
+  __uint16_t		fop;
+  __uint64_t		rip;
+  __uint64_t		rdp;
+  __uint32_t		mxcsr;
+  __uint32_t		mxcr_mask;
+  struct _libc_fpxreg	_st[8];
+  struct _libc_xmmreg	_xmm[16];
+  __uint32_t		padding[24];
+};
+
+/* Structure to describe FPU registers.  */
+typedef struct _libc_fpstate *fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct
+  {
+    gregset_t gregs;
+    /* Note that fpregs is a pointer.  */
+    fpregset_t fpregs;
+    unsigned long __reserved1 [8];
+} mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+    struct _libc_fpstate __fpregs_mem;
+  } ucontext_t;
+
+#else /* __WORDSIZE == 32 */
 
 /* Type for general register.  */
 typedef int greg_t;
@@ -126,4 +243,6 @@ typedef struct ucontext
     struct _libc_fpstate __fpregs_mem;
   } ucontext_t;
 
+#endif /* __WORDSIZE == 32 */
+
 #endif /* sys/ucontext.h */
Index: git/sysdeps/unix/sysv/linux/i386/sys/user.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/i386/sys/user.h
+++ git/sysdeps/unix/sysv/linux/i386/sys/user.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1998, 2000 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,6 +23,77 @@
    too much into it.  Don't use it for anything other than GDB unless
    you know what you are doing.  */
 
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+
+struct user_fpregs_struct
+{
+  __uint16_t		cwd;
+  __uint16_t		swd;
+  __uint16_t		ftw;
+  __uint16_t		fop;
+  __uint64_t		rip;
+  __uint64_t		rdp;
+  __uint32_t		mxcsr;
+  __uint32_t		mxcr_mask;
+  __uint32_t		st_space[32];   /* 8*16 bytes for each FP-reg = 128 bytes */
+  __uint32_t		xmm_space[64];  /* 16*16 bytes for each XMM-reg = 256 bytes */
+  __uint32_t		padding[24];
+};
+
+struct user_regs_struct
+{
+  unsigned long r15;
+  unsigned long r14;
+  unsigned long r13;
+  unsigned long r12;
+  unsigned long rbp;
+  unsigned long rbx;
+  unsigned long r11;
+  unsigned long r10;
+  unsigned long r9;
+  unsigned long r8;
+  unsigned long rax;
+  unsigned long rcx;
+  unsigned long rdx;
+  unsigned long rsi;
+  unsigned long rdi;
+  unsigned long orig_rax;
+  unsigned long rip;
+  unsigned long cs;
+  unsigned long eflags;
+  unsigned long rsp;
+  unsigned long ss;
+  unsigned long fs_base;
+  unsigned long gs_base;
+  unsigned long ds;
+  unsigned long es;
+  unsigned long fs;
+  unsigned long gs;
+};
+
+struct user
+{
+  struct user_regs_struct	regs;
+  int				u_fpvalid;
+  struct user_fpregs_struct	i387;
+  unsigned long int		u_tsize;
+  unsigned long int		u_dsize;
+  unsigned long int		u_ssize;
+  unsigned long			start_code;
+  unsigned long			start_stack;
+  long int			signal;
+  int				reserved;
+  struct user_regs_struct*	u_ar0;
+  struct user_fpregs_struct*	u_fpstate;
+  unsigned long int		magic;
+  char				u_comm [32];
+  unsigned long int		u_debugreg [8];
+};
+
+#else
+/* These are the 32-bit x86 structures.  */
 struct user_fpregs_struct
 {
   long int cwd;
@@ -91,6 +162,7 @@ struct user
   char				u_comm [32];
   int				u_debugreg [8];
 };
+#endif  /* __WORDSIZE */
 
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(1UL << PAGE_SHIFT)
Index: git/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
+++ git/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
@@ -1,5 +1,5 @@
-/* O_*, F_*, FD_* bit values for Linux/x86-64.
-   Copyright (C) 2001,2002,2004,2006,2007,2009,2010,2011
+/* O_*, F_*, FD_* bit values for Linux/i386/x86-64.
+   Copyright (C) 1995,1996,1997,1998,2000,2001,2002,2004,2006,2007,2009,2010
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
Index: git/sysdeps/unix/sysv/linux/x86_64/bits/mman.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/bits/mman.h
+++ git/sysdeps/unix/sysv/linux/x86_64/bits/mman.h
@@ -1,5 +1,5 @@
-/* Definitions for POSIX memory map interface.  Linux/x86_64 version.
-   Copyright (C) 2001,2003,2005,2006,2009,2010,2011
+/* Definitions for POSIX memory map interface.  Linux/i386/x86_64 version.
+   Copyright (C) 1997,2000,2001,2003,2005,2006,2009,2010,2011
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
Index: git/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* Copyright (C) 2002 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#ifndef _SYS_SEM_H
-# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
-#endif
-
-#include <sys/types.h>
-
-/* Flags for `semop'.  */
-#define SEM_UNDO	0x1000		/* undo the operation on exit */
-
-/* Commands for `semctl'.  */
-#define GETPID		11		/* get sempid */
-#define GETVAL		12		/* get semval */
-#define GETALL		13		/* get all semval's */
-#define GETNCNT		14		/* get semncnt */
-#define GETZCNT		15		/* get semzcnt */
-#define SETVAL		16		/* set semval */
-#define SETALL		17		/* set all semval's */
-
-
-/* Data structure describing a set of semaphores.  */
-struct semid_ds
-{
-  struct ipc_perm sem_perm;		/* operation permission struct */
-  __time_t sem_otime;			/* last semop() time */
-  unsigned long int __unused1;
-  __time_t sem_ctime;			/* last time changed by semctl() */
-  unsigned long int __unused2;
-  unsigned long int sem_nsems;		/* number of semaphores in set */
-  unsigned long int __unused3;
-  unsigned long int __unused4;
-};
-
-/* The user should define a union like the following to use it for arguments
-   for `semctl'.
-
-   union semun
-   {
-     int val;				<= value for SETVAL
-     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
-     unsigned short int *array;		<= array for GETALL & SETALL
-     struct seminfo *__buf;		<= buffer for IPC_INFO
-   };
-
-   Previous versions of this file used to define this union but this is
-   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
-   one must define the union or not.  */
-#define _SEM_SEMUN_UNDEFINED	1
-
-#ifdef __USE_MISC
-
-/* ipcs ctl cmds */
-# define SEM_STAT 18
-# define SEM_INFO 19
-
-struct  seminfo
-{
-  int semmap;
-  int semmni;
-  int semmns;
-  int semmnu;
-  int semmsl;
-  int semopm;
-  int semume;
-  int semusz;
-  int semvmx;
-  int semaem;
-};
-
-#endif /* __USE_MISC */
Index: git/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
+++ git/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
Index: git/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
+++ git/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2004 Free Software Foundation, Inc.
+/* Copyright (C) 1996, 1997, 1999, 2000, 2001, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
Index: git/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
+++ git/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
Index: git/sysdeps/unix/sysv/linux/x86_64/sys/user.h
===================================================================
--- git.orig/sysdeps/unix/sysv/linux/x86_64/sys/user.h
+++ git/sysdeps/unix/sysv/linux/x86_64/sys/user.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2002, 2004, 2011 Free Software Foundation, Inc.
+/* Copyright (C) 1998, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
Index: git/sysdeps/x86_64/bits/byteswap.h
===================================================================
--- git.orig/sysdeps/x86_64/bits/byteswap.h
+++ git/sysdeps/x86_64/bits/byteswap.h
@@ -1,5 +1,5 @@
 /* Macros to swap the order of bytes in integer values.
-   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2007, 2008, 2010
+   Copyright (C) 1997, 1998, 2000, 2002, 2003, 2006, 2007, 2008, 2010
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
Index: git/sysdeps/x86_64/bits/endian.h
===================================================================
--- git.orig/sysdeps/x86_64/bits/endian.h
+++ git/sysdeps/x86_64/bits/endian.h
@@ -1,4 +1,4 @@
-/* x86_64 is little-endian.  */
+/* i386/x86_64 is little-endian.  */
 
 #ifndef _ENDIAN_H
 # error "Never use <bits/endian.h> directly; include <endian.h> instead."
Index: git/sysdeps/x86_64/bits/huge_vall.h
===================================================================
--- /dev/null
+++ git/sysdeps/x86_64/bits/huge_vall.h
@@ -0,0 +1,47 @@
+/* `HUGE_VALL' constant for ix86 (where it is infinity).
+   Used by <stdlib.h> and <math.h> functions for overflow.
+   Copyright (C) 1992, 1995, 1996, 1997, 1999, 2000, 2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/huge_vall.h> directly; include <math.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#if __GNUC_PREREQ(3,3)
+# define HUGE_VALL	(__builtin_huge_vall())
+#elif __GNUC_PREREQ(2,96) && __WORDSIZE == 32
+# define HUGE_VALL	(__extension__ 0x1.0p32767L)
+#else
+#if __WORDSIZE == 32
+# define __HUGE_VALL_bytes	{ 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }
+
+# define __huge_vall_t	union { unsigned char __c[12]; long double __ld; }
+# ifdef __GNUC__
+#  define HUGE_VALL	(__extension__ \
+			 ((__huge_vall_t) { __c: __HUGE_VALL_bytes }).__ld)
+# else	/* Not GCC.  */
+static __huge_vall_t __huge_vall = { __HUGE_VALL_bytes };
+#  define HUGE_VALL	(__huge_vall.__ld)
+#  endif /* GCC.  */
+#else /* __WORDSIZE == 64 */
+# define HUGE_VALL	((long double) HUGE_VAL)
+#endif /* __WORDSIZE */
+#endif /* GCC 2.95 */
Index: git/sysdeps/x86_64/bits/mathdef.h
===================================================================
--- git.orig/sysdeps/x86_64/bits/mathdef.h
+++ git/sysdeps/x86_64/bits/mathdef.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2004, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001, 2004, 2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
Index: git/sysdeps/x86_64/bits/setjmp.h
===================================================================
--- git.orig/sysdeps/x86_64/bits/setjmp.h
+++ git/sysdeps/x86_64/bits/setjmp.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001,2002,2003,2005,2006 Free Software Foundation, Inc.
+/* Copyright (C) 1997,1998,2000,2001,2002,2003,2005,2006 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -16,7 +16,7 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
-/* Define the machine-dependent type `jmp_buf'.  x86-64 version.  */
+/* Define the machine-dependent type `jmp_buf'.  i386/x86-64 version.  */
 #ifndef _BITS_SETJMP_H
 #define _BITS_SETJMP_H  1
 
Index: git/sysdeps/x86_64/bits/string.h
===================================================================
--- git.orig/sysdeps/x86_64/bits/string.h
+++ git/sysdeps/x86_64/bits/string.h
@@ -1,5 +1,6 @@
-/* Optimized, inlined string functions.  AMD x86-64 version.
-   Copyright (C) 2001 Free Software Foundation, Inc.
+/* Optimized, inlined string functions.  i486/x86-64 version.
+   Copyright (C) 1997,1998,1999,2000,2001,2002,2003,2004,2007
+   	Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,6 +22,1955 @@
 # error "Never use <bits/string.h> directly; include <string.h> instead."
 #endif
 
-/* Currently the only purpose of this file is to tell the generic inline
-   macros that unaligned memory access is possible for x86-64.  */
+/* The ix86 processors can access unaligned multi-byte variables.  */
 #define _STRING_ARCH_unaligned	1
+
+#include <bits/wordsize.h>
+
+/* We only provide optimizations if the user selects them and if
+   GNU CC is used.  */
+#if __WORDSIZE == 32 && !defined __NO_STRING_INLINES && defined __USE_STRING_INLINES \
+    && defined __GNUC__ && __GNUC__ >= 2 && !__BOUNDED_POINTERS__
+
+#ifndef __STRING_INLINE
+# ifndef __extern_inline
+#  define __STRING_INLINE inline
+# else
+#  define __STRING_INLINE __extern_inline
+# endif
+#endif
+
+/* The macros are used in some of the optimized implementations below.  */
+#define __STRING_SMALL_GET16(src, idx) \
+  ((((__const unsigned char *) (src))[idx + 1] << 8)			      \
+   | ((__const unsigned char *) (src))[idx])
+#define __STRING_SMALL_GET32(src, idx) \
+  (((((__const unsigned char *) (src))[idx + 3] << 8			      \
+     | ((__const unsigned char *) (src))[idx + 2]) << 8			      \
+    | ((__const unsigned char *) (src))[idx + 1]) << 8			      \
+   | ((__const unsigned char *) (src))[idx])
+
+
+/* Copy N bytes of SRC to DEST.  */
+#define _HAVE_STRING_ARCH_memcpy 1
+#define memcpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (n)				      \
+		  ? __memcpy_c ((dest), (src), (n))			      \
+		  : __memcpy_g ((dest), (src), (n))))
+#define __memcpy_c(dest, src, n) \
+  ((n) == 0								      \
+   ? (dest)								      \
+   : (((n) % 4 == 0)							      \
+      ? __memcpy_by4 (dest, src, n)					      \
+      : (((n) % 2 == 0)							      \
+	 ? __memcpy_by2 (dest, src, n)					      \
+	 : __memcpy_g (dest, src, n))))
+
+__STRING_INLINE void *__memcpy_by4 (void *__dest, __const void *__src,
+				    size_t __n);
+
+__STRING_INLINE void *
+__memcpy_by4 (void *__dest, __const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __dest;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b"
+     : "=&r" (__d0), "=&r" (__tmp), "=&r" (__src), "=&r" (__d1)
+     : "1" (__tmp), "2" (__src), "3" (__n / 4)
+     : "memory", "cc");
+  return __dest;
+}
+
+__STRING_INLINE void *__memcpy_by2 (void *__dest, __const void *__src,
+				    size_t __n);
+
+__STRING_INLINE void *
+__memcpy_by2 (void *__dest, __const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __dest;
+  __asm__ __volatile__
+    ("shrl	$1,%3\n\t"
+     "jz	2f\n"                 /* only a word */
+     "1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b\n"
+     "2:\n\t"
+     "movw	(%2),%w0\n\t"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=&r" (__tmp), "=&r" (__src), "=&r" (__d1)
+     : "1" (__tmp), "2" (__src), "3" (__n / 2)
+     : "memory", "cc");
+  return __dest;
+}
+
+__STRING_INLINE void *__memcpy_g (void *__dest, __const void *__src,
+				  size_t __n);
+
+__STRING_INLINE void *
+__memcpy_g (void *__dest, __const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register void *__tmp = __dest;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	1f\n\t"
+     "movsb\n"
+     "1:\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	2f\n\t"
+     "movsw\n"
+     "2:\n\t"
+     "rep; movsl"
+     : "=&c" (__d0), "=&D" (__d1), "=&S" (__d2),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__dest)
+     : "0" (__n), "1" (__tmp), "2" (__src),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__src)
+     : "cc");
+  return __dest;
+}
+
+#define _HAVE_STRING_ARCH_memmove 1
+#ifndef _FORCE_INLINES
+/* Copy N bytes of SRC to DEST, guaranteeing
+   correct behavior for overlapping strings.  */
+#define memmove(dest, src, n) __memmove_g (dest, src, n)
+
+__STRING_INLINE void *__memmove_g (void *, __const void *, size_t)
+     __asm__ ("memmove");
+
+__STRING_INLINE void *
+__memmove_g (void *__dest, __const void *__src, size_t __n)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register void *__tmp = __dest;
+  if (__dest < __src)
+    __asm__ __volatile__
+      ("cld\n\t"
+       "rep; movsb"
+       : "=&c" (__d0), "=&S" (__d1), "=&D" (__d2),
+	 "=m" ( *(struct { __extension__ char __x[__n]; } *)__dest)
+       : "0" (__n), "1" (__src), "2" (__tmp),
+	 "m" ( *(struct { __extension__ char __x[__n]; } *)__src));
+  else
+    __asm__ __volatile__
+      ("std\n\t"
+       "rep; movsb\n\t"
+       "cld"
+       : "=&c" (__d0), "=&S" (__d1), "=&D" (__d2),
+	 "=m" ( *(struct { __extension__ char __x[__n]; } *)__dest)
+       : "0" (__n), "1" (__n - 1 + (__const char *) __src),
+	 "2" (__n - 1 + (char *) __tmp),
+	 "m" ( *(struct { __extension__ char __x[__n]; } *)__src));
+  return __dest;
+}
+#endif
+
+/* Compare N bytes of S1 and S2.  */
+#define _HAVE_STRING_ARCH_memcmp 1
+#ifndef _FORCE_INLINES
+# ifndef __PIC__
+/* gcc has problems to spill registers when using PIC.  */
+__STRING_INLINE int
+memcmp (__const void *__s1, __const void *__s2, size_t __n)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register int __res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "testl %3,%3\n\t"
+     "repe; cmpsb\n\t"
+     "je	1f\n\t"
+     "sbbl	%0,%0\n\t"
+     "orl	$1,%0\n"
+     "1:"
+     : "=&a" (__res), "=&S" (__d0), "=&D" (__d1), "=&c" (__d2)
+     : "0" (0), "1" (__s1), "2" (__s2), "3" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s2)
+     : "cc");
+  return __res;
+}
+# endif
+#endif
+
+/* Set N bytes of S to C.  */
+#define _HAVE_STRING_ARCH_memset 1
+#define _USE_STRING_ARCH_memset 1
+#define memset(s, c, n) \
+  (__extension__ (__builtin_constant_p (n) && (n) <= 16			      \
+		  ? ((n) == 1						      \
+		     ? __memset_c1 ((s), (c))				      \
+		     : __memset_gc ((s), (c), (n)))			      \
+		  : (__builtin_constant_p (c)				      \
+		     ? (__builtin_constant_p (n)			      \
+			? __memset_ccn ((s), (c), (n))			      \
+			: memset ((s), (c), (n)))			      \
+		     : (__builtin_constant_p (n)			      \
+			? __memset_gcn ((s), (c), (n))			      \
+			: memset ((s), (c), (n))))))
+
+#define __memset_c1(s, c) ({ void *__s = (s);				      \
+			     *((unsigned char *) __s) = (unsigned char) (c);  \
+			     __s; })
+
+#define __memset_gc(s, c, n) \
+  ({ void *__s = (s);							      \
+     union {								      \
+       unsigned int __ui;						      \
+       unsigned short int __usi;					      \
+       unsigned char __uc;						      \
+     } *__u = __s;							      \
+     unsigned int __c = ((unsigned int) ((unsigned char) (c))) * 0x01010101;  \
+									      \
+     /* We apply a trick here.  `gcc' would implement the following	      \
+	assignments using immediate operands.  But this uses to much	      \
+	memory (7, instead of 4 bytes).  So we force the value in a	      \
+	registers.  */							      \
+     if ((n) == 3 || (n) >= 5)						      \
+       __asm__ __volatile__ ("" : "=r" (__c) : "0" (__c));		      \
+									      \
+     /* This `switch' statement will be removed at compile-time.  */	      \
+     switch (n)								      \
+       {								      \
+       case 15:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 11:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 7:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 3:								      \
+	 __u->__usi = (unsigned short int) __c;				      \
+	 __u = __extension__ ((void *) __u + 2);			      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 14:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 10:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 6:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 2:								      \
+	 __u->__usi = (unsigned short int) __c;				      \
+	 break;								      \
+									      \
+       case 13:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 9:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 5:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 1:								      \
+	 __u->__uc = (unsigned char) __c;				      \
+	 break;								      \
+									      \
+       case 16:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 12:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 8:								      \
+	 __u->__ui = __c;						      \
+	 __u = __extension__ ((void *) __u + 4);			      \
+       case 4:								      \
+	 __u->__ui = __c;						      \
+       case 0:								      \
+	 break;								      \
+       }								      \
+									      \
+     __s; })
+
+#define __memset_ccn(s, c, n) \
+  (((n) % 4 == 0)							      \
+   ? __memset_ccn_by4 (s, ((unsigned int) ((unsigned char) (c))) * 0x01010101,\
+		       n)						      \
+   : (((n) % 2 == 0)							      \
+      ? __memset_ccn_by2 (s,						      \
+			  ((unsigned int) ((unsigned char) (c))) * 0x01010101,\
+			   n)						      \
+      : memset (s, c, n)))
+
+__STRING_INLINE void *__memset_ccn_by4 (void *__s, unsigned int __c,
+					size_t __n);
+
+__STRING_INLINE void *
+__memset_ccn_by4 (void *__s, unsigned int __c, size_t __n)
+{
+  register void *__tmp = __s;
+  register unsigned long int __d0;
+#ifdef __i686__
+  __asm__ __volatile__
+    ("cld\n\t"
+     "rep; stosl"
+     : "=&a" (__c), "=&D" (__tmp), "=&c" (__d0),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+#else
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	%0,(%1)\n\t"
+     "addl	$4,%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     : "=&r" (__c), "=&r" (__tmp), "=&r" (__d0),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+#endif
+  return __s;
+}
+
+__STRING_INLINE void *__memset_ccn_by2 (void *__s, unsigned int __c,
+					size_t __n);
+
+__STRING_INLINE void *
+__memset_ccn_by2 (void *__s, unsigned int __c, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __s;
+#ifdef __i686__
+  __asm__ __volatile__
+    ("cld\n\t"
+     "rep; stosl\n"
+     "stosw"
+     : "=&a" (__d0), "=&D" (__tmp), "=&c" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+#else
+  __asm__ __volatile__
+    ("1:\tmovl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=&r" (__tmp), "=&r" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+#endif
+  return __s;
+}
+
+#define __memset_gcn(s, c, n) \
+  (((n) % 4 == 0)							      \
+   ? __memset_gcn_by4 (s, c, n)						      \
+   : (((n) % 2 == 0)							      \
+      ? __memset_gcn_by2 (s, c, n)					      \
+      : memset (s, c, n)))
+
+__STRING_INLINE void *__memset_gcn_by4 (void *__s, int __c, size_t __n);
+
+__STRING_INLINE void *
+__memset_gcn_by4 (void *__s, int __c, size_t __n)
+{
+  register void *__tmp = __s;
+  register unsigned long int __d0;
+  __asm__ __volatile__
+    ("movb	%b0,%h0\n"
+     "pushw	%w0\n\t"
+     "shll	$16,%0\n\t"
+     "popw	%w0\n"
+     "1:\n\t"
+     "movl	%0,(%1)\n\t"
+     "addl	$4,%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     : "=&q" (__c), "=&r" (__tmp), "=&r" (__d0),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+  return __s;
+}
+
+__STRING_INLINE void *__memset_gcn_by2 (void *__s, int __c, size_t __n);
+
+__STRING_INLINE void *
+__memset_gcn_by2 (void *__s, int __c, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register void *__tmp = __s;
+  __asm__ __volatile__
+    ("movb	%b0,%h0\n\t"
+     "pushw	%w0\n\t"
+     "shll	$16,%0\n\t"
+     "popw	%w0\n"
+     "1:\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%2\n\t"
+     "jnz	1b\n"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=&r" (__tmp), "=&r" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "0" ((unsigned int) __c), "1" (__tmp), "2" (__n / 4)
+     : "cc");
+  return __s;
+}
+
+
+/* Search N bytes of S for C.  */
+#define _HAVE_STRING_ARCH_memchr 1
+#ifndef _FORCE_INLINES
+__STRING_INLINE void *
+memchr (__const void *__s, int __c, size_t __n)
+{
+  register unsigned long int __d0;
+#ifdef __i686__
+  register unsigned long int __d1;
+#endif
+  register unsigned char *__res;
+  if (__n == 0)
+    return NULL;
+#ifdef __i686__
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "cmovne %2,%0"
+     : "=D" (__res), "=&c" (__d0), "=&r" (__d1)
+     : "a" (__c), "0" (__s), "1" (__n), "2" (1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+#else
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "je	1f\n\t"
+     "movl	$1,%0\n"
+     "1:"
+     : "=D" (__res), "=&c" (__d0)
+     : "a" (__c), "0" (__s), "1" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+#endif
+  return __res - 1;
+}
+#endif
+
+#define _HAVE_STRING_ARCH_memrchr 1
+#ifndef _FORCE_INLINES
+__STRING_INLINE void *__memrchr (__const void *__s, int __c, size_t __n);
+
+__STRING_INLINE void *
+__memrchr (__const void *__s, int __c, size_t __n)
+{
+  register unsigned long int __d0;
+# ifdef __i686__
+  register unsigned long int __d1;
+# endif
+  register void *__res;
+  if (__n == 0)
+    return NULL;
+# ifdef __i686__
+  __asm__ __volatile__
+    ("std\n\t"
+     "repne; scasb\n\t"
+     "cmovne %2,%0\n\t"
+     "cld\n\t"
+     "incl %0"
+     : "=D" (__res), "=&c" (__d0), "=&r" (__d1)
+     : "a" (__c), "0" (__s + __n - 1), "1" (__n), "2" (-1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+# else
+  __asm__ __volatile__
+    ("std\n\t"
+     "repne; scasb\n\t"
+     "je 1f\n\t"
+     "orl $-1,%0\n"
+     "1:\tcld\n\t"
+     "incl %0"
+     : "=D" (__res), "=&c" (__d0)
+     : "a" (__c), "0" (__s + __n - 1), "1" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s)
+     : "cc");
+# endif
+  return __res;
+}
+# ifdef __USE_GNU
+#  define memrchr(s, c, n) __memrchr ((s), (c), (n))
+# endif
+#endif
+
+/* Return pointer to C in S.  */
+#define _HAVE_STRING_ARCH_rawmemchr 1
+__STRING_INLINE void *__rawmemchr (const void *__s, int __c);
+
+#ifndef _FORCE_INLINES
+__STRING_INLINE void *
+__rawmemchr (const void *__s, int __c)
+{
+  register unsigned long int __d0;
+  register unsigned char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     : "=D" (__res), "=&c" (__d0)
+     : "a" (__c), "0" (__s), "1" (0xffffffff),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res - 1;
+}
+# ifdef __USE_GNU
+__STRING_INLINE void *
+rawmemchr (const void *__s, int __c)
+{
+  return __rawmemchr (__s, __c);
+}
+# endif	/* use GNU */
+#endif
+
+
+/* Return the length of S.  */
+#define _HAVE_STRING_ARCH_strlen 1
+#define strlen(str) \
+  (__extension__ (__builtin_constant_p (str)				      \
+		  ? __builtin_strlen (str)				      \
+		  : __strlen_g (str)))
+__STRING_INLINE size_t __strlen_g (__const char *__str);
+
+__STRING_INLINE size_t
+__strlen_g (__const char *__str)
+{
+  register char __dummy;
+  register __const char *__tmp = __str;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%b1\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%b1,%b1\n\t"
+     "jne	1b"
+     : "=r" (__tmp), "=&q" (__dummy)
+     : "0" (__str),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__str)
+     : "cc" );
+  return __tmp - __str - 1;
+}
+
+
+/* Copy SRC to DEST.  */
+#define _HAVE_STRING_ARCH_strcpy 1
+#define strcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (sizeof ((src)[0]) == 1 && strlen (src) + 1 <= 8	      \
+		     ? __strcpy_a_small ((dest), (src), strlen (src) + 1)     \
+		     : (char *) memcpy ((char *) (dest),		      \
+					(__const char *) (src),		      \
+					strlen (src) + 1))		      \
+		  : __strcpy_g ((dest), (src))))
+
+#define __strcpy_a_small(dest, src, srclen) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    union {						      \
+		      unsigned int __ui;				      \
+		      unsigned short int __usi;				      \
+		      unsigned char __uc;				      \
+		      char __c;						      \
+		    } *__u = (void *) __dest;				      \
+		    switch (srclen)					      \
+		      {							      \
+		      case 1:						      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 2:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			break;						      \
+		      case 3:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 4:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			break;						      \
+		      case 5:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 6:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			break;						      \
+		      case 7:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 8:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 4);	      \
+			break;						      \
+		      }							      \
+		    (char *) __dest; }))
+
+__STRING_INLINE char *__strcpy_g (char *__dest, __const char *__src);
+
+__STRING_INLINE char *
+__strcpy_g (char *__dest, __const char *__src)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+  __asm__ __volatile__
+    (
+     "1:\n\t"
+     "movb	(%0),%b2\n\t"
+     "leal	1(%0),%0\n\t"
+     "movb	%b2,(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne	1b"
+     : "=&r" (__src), "=&r" (__tmp), "=&q" (__dummy),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__src), "1" (__tmp),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
+     : "cc");
+  return __dest;
+}
+
+
+#ifdef __USE_GNU
+# define _HAVE_STRING_ARCH_stpcpy 1
+/* Copy SRC to DEST.  */
+# define __stpcpy(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? (strlen (src) + 1 <= 8				      \
+		     ? __stpcpy_a_small ((dest), (src), strlen (src) + 1)     \
+		     : __stpcpy_c ((dest), (src), strlen (src) + 1))	      \
+		  : __stpcpy_g ((dest), (src))))
+# define __stpcpy_c(dest, src, srclen) \
+  ((srclen) % 4 == 0							      \
+   ? __mempcpy_by4 (dest, src, srclen) - 1				      \
+   : ((srclen) % 2 == 0							      \
+      ? __mempcpy_by2 (dest, src, srclen) - 1				      \
+      : __mempcpy_byn (dest, src, srclen) - 1))
+
+/* In glibc itself we use this symbol for namespace reasons.  */
+# define stpcpy(dest, src) __stpcpy ((dest), (src))
+
+# define __stpcpy_a_small(dest, src, srclen) \
+  (__extension__ ({ union {						      \
+		      unsigned int __ui;				      \
+		      unsigned short int __usi;				      \
+		      unsigned char __uc;				      \
+		      char __c;						      \
+		    } *__u = (void *) (dest);				      \
+		    switch (srclen)					      \
+		      {							      \
+		      case 1:						      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 2:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 1);		      \
+			break;						      \
+		      case 3:						      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 4:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 3);		      \
+			break;						      \
+		      case 5:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 6:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 1);		      \
+			break;						      \
+		      case 7:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__usi = __STRING_SMALL_GET16 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 2);		      \
+			__u->__uc = '\0';				      \
+			break;						      \
+		      case 8:						      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 0);	      \
+			__u = __extension__ ((void *) __u + 4);		      \
+			__u->__ui = __STRING_SMALL_GET32 (src, 4);	      \
+			__u = __extension__ ((void *) __u + 3);		      \
+			break;						      \
+		      }							      \
+		    (char *) __u; }))
+
+__STRING_INLINE char *__mempcpy_by4 (char *__dest, __const char *__src,
+				     size_t __srclen);
+
+__STRING_INLINE char *
+__mempcpy_by4 (char *__dest, __const char *__src, size_t __srclen)
+{
+  register char *__tmp = __dest;
+  register unsigned long int __d0, __d1;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b"
+     : "=&r" (__d0), "=r" (__tmp), "=&r" (__src), "=&r" (__d1)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 4)
+     : "memory", "cc");
+  return __tmp;
+}
+
+__STRING_INLINE char *__mempcpy_by2 (char *__dest, __const char *__src,
+				     size_t __srclen);
+
+__STRING_INLINE char *
+__mempcpy_by2 (char *__dest, __const char *__src, size_t __srclen)
+{
+  register char *__tmp = __dest;
+  register unsigned long int __d0, __d1;
+  __asm__ __volatile__
+    ("shrl	$1,%3\n\t"
+     "jz	2f\n"                 /* only a word */
+     "1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b\n"
+     "2:\n\t"
+     "movw	(%2),%w0\n\t"
+     "movw	%w0,(%1)"
+     : "=&q" (__d0), "=r" (__tmp), "=&r" (__src), "=&r" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 2),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  return __tmp + 2;
+}
+
+__STRING_INLINE char *__mempcpy_byn (char *__dest, __const char *__src,
+				     size_t __srclen);
+
+__STRING_INLINE char *
+__mempcpy_byn (char *__dest, __const char *__src, size_t __srclen)
+{
+  register unsigned long __d0, __d1;
+  register char *__tmp = __dest;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	1f\n\t"
+     "movsb\n"
+     "1:\n\t"
+     "shrl	$1,%%ecx\n\t"
+     "jnc	2f\n\t"
+     "movsw\n"
+     "2:\n\t"
+     "rep; movsl"
+     : "=D" (__tmp), "=&c" (__d0), "=&S" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "0" (__tmp), "1" (__srclen), "2" (__src),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  return __tmp;
+}
+
+__STRING_INLINE char *__stpcpy_g (char *__dest, __const char *__src);
+
+__STRING_INLINE char *
+__stpcpy_g (char *__dest, __const char *__src)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+  __asm__ __volatile__
+    (
+     "1:\n\t"
+     "movb	(%0),%b2\n\t"
+     "leal	1(%0),%0\n\t"
+     "movb	%b2,(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne	1b"
+     : "=&r" (__src), "=r" (__tmp), "=&q" (__dummy),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__src), "1" (__tmp),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
+     : "cc");
+  return __tmp - 1;
+}
+#endif
+
+
+/* Copy no more than N characters of SRC to DEST.  */
+#define _HAVE_STRING_ARCH_strncpy 1
+#define strncpy(dest, src, n) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? ((strlen (src) + 1 >= ((size_t) (n))		      \
+		      ? (char *) memcpy ((char *) (dest),		      \
+					 (__const char *) (src), n)	      \
+		      : __strncpy_cg ((dest), (src), strlen (src) + 1, n)))   \
+		  : __strncpy_gg ((dest), (src), n)))
+#define __strncpy_cg(dest, src, srclen, n) \
+  (((srclen) % 4 == 0)							      \
+   ? __strncpy_by4 (dest, src, srclen, n)				      \
+   : (((srclen) % 2 == 0)						      \
+      ? __strncpy_by2 (dest, src, srclen, n)				      \
+      : __strncpy_byn (dest, src, srclen, n)))
+
+__STRING_INLINE char *__strncpy_by4 (char *__dest, __const char __src[],
+				     size_t __srclen, size_t __n);
+
+__STRING_INLINE char *
+__strncpy_by4 (char *__dest, __const char __src[], size_t __srclen, size_t __n)
+{
+  register char *__tmp = __dest;
+  register int __dummy1, __dummy2;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b"
+     : "=&r" (__dummy1), "=r" (__tmp), "=&r" (__src), "=&r" (__dummy2),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 4),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  (void) memset (__tmp, '\0', __n - __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strncpy_by2 (char *__dest, __const char __src[],
+				     size_t __srclen, size_t __n);
+
+__STRING_INLINE char *
+__strncpy_by2 (char *__dest, __const char __src[], size_t __srclen, size_t __n)
+{
+  register char *__tmp = __dest;
+  register int __dummy1, __dummy2;
+  __asm__ __volatile__
+    ("shrl	$1,%3\n\t"
+     "jz	2f\n"                 /* only a word */
+     "1:\n\t"
+     "movl	(%2),%0\n\t"
+     "leal	4(%2),%2\n\t"
+     "movl	%0,(%1)\n\t"
+     "leal	4(%1),%1\n\t"
+     "decl	%3\n\t"
+     "jnz	1b\n"
+     "2:\n\t"
+     "movw	(%2),%w0\n\t"
+     "movw	%w0,(%1)\n\t"
+     : "=&q" (__dummy1), "=r" (__tmp), "=&r" (__src), "=&r" (__dummy2),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__tmp), "2" (__src), "3" (__srclen / 2),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  (void) memset (__tmp + 2, '\0', __n - __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strncpy_byn (char *__dest, __const char __src[],
+				     size_t __srclen, size_t __n);
+
+__STRING_INLINE char *
+__strncpy_byn (char *__dest, __const char __src[], size_t __srclen, size_t __n)
+{
+  register unsigned long int __d0, __d1;
+  register char *__tmp = __dest;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "shrl	$1,%1\n\t"
+     "jnc	1f\n\t"
+     "movsb\n"
+     "1:\n\t"
+     "shrl	$1,%1\n\t"
+     "jnc	2f\n\t"
+     "movsw\n"
+     "2:\n\t"
+     "rep; movsl"
+     : "=D" (__tmp), "=&c" (__d0), "=&S" (__d1),
+       "=m" ( *(struct { __extension__ char __x[__srclen]; } *)__dest)
+     : "1" (__srclen), "0" (__tmp),"2" (__src),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  (void) memset (__tmp, '\0', __n - __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strncpy_gg (char *__dest, __const char *__src,
+				    size_t __n);
+
+__STRING_INLINE char *
+__strncpy_gg (char *__dest, __const char *__src, size_t __n)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+  if (__n > 0)
+    __asm__ __volatile__
+      ("1:\n\t"
+       "movb	(%0),%2\n\t"
+       "incl	%0\n\t"
+       "movb	%2,(%1)\n\t"
+       "incl	%1\n\t"
+       "decl	%3\n\t"
+       "je	3f\n\t"
+       "testb	%2,%2\n\t"
+       "jne	1b\n\t"
+       "2:\n\t"
+       "movb	%2,(%1)\n\t"
+       "incl	%1\n\t"
+       "decl	%3\n\t"
+       "jne	2b\n\t"
+       "3:"
+       : "=&r" (__src), "=&r" (__tmp), "=&q" (__dummy), "=&r" (__n)
+       : "0" (__src), "1" (__tmp), "3" (__n)
+       : "memory", "cc");
+
+  return __dest;
+}
+
+
+/* Append SRC onto DEST.  */
+#define _HAVE_STRING_ARCH_strcat 1
+#define strcat(dest, src) \
+  (__extension__ (__builtin_constant_p (src)				      \
+		  ? __strcat_c ((dest), (src), strlen (src) + 1)	      \
+		  : __strcat_g ((dest), (src))))
+
+__STRING_INLINE char *__strcat_c (char *__dest, __const char __src[],
+				  size_t __srclen);
+
+__STRING_INLINE char *
+__strcat_c (char *__dest, __const char __src[], size_t __srclen)
+{
+#ifdef __i686__
+  register unsigned long int __d0;
+  register char *__tmp;
+  __asm__ __volatile__
+    ("repne; scasb"
+     : "=D" (__tmp), "=&c" (__d0),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__dest), "1" (0xffffffff), "a" (0),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+  --__tmp;
+#else
+  register char *__tmp = __dest - 1;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "incl	%0\n\t"
+     "cmpb	$0,(%0)\n\t"
+     "jne	1b\n"
+     : "=r" (__tmp),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "0" (__tmp),
+       "m" ( *(struct { __extension__ char __x[__srclen]; } *)__src)
+     : "cc");
+#endif
+  (void) memcpy (__tmp, __src, __srclen);
+  return __dest;
+}
+
+__STRING_INLINE char *__strcat_g (char *__dest, __const char *__src);
+
+__STRING_INLINE char *
+__strcat_g (char *__dest, __const char *__src)
+{
+  register char *__tmp = __dest - 1;
+  register char __dummy;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "incl	%1\n\t"
+     "cmpb	$0,(%1)\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "movb	(%2),%b0\n\t"
+     "incl	%2\n\t"
+     "movb	%b0,(%1)\n\t"
+     "incl	%1\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	2b\n"
+     : "=&q" (__dummy), "=&r" (__tmp), "=&r" (__src),
+       "=m" ( *(struct { char __x[0xfffffff]; } *)__dest)
+     : "1"  (__tmp), "2"  (__src),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__src)
+     : "memory", "cc");
+  return __dest;
+}
+
+
+/* Append no more than N characters from SRC onto DEST.  */
+#define _HAVE_STRING_ARCH_strncat 1
+#define strncat(dest, src, n) \
+  (__extension__ ({ char *__dest = (dest);				      \
+		    __builtin_constant_p (src) && __builtin_constant_p (n)    \
+		    ? (strlen (src) < ((size_t) (n))			      \
+		       ? strcat (__dest, (src))				      \
+		       : (*(char *)__mempcpy (strchr (__dest, '\0'),	      \
+					       (__const char *) (src),	      \
+					      (n)) = 0, __dest))	      \
+		    : __strncat_g (__dest, (src), (n)); }))
+
+__STRING_INLINE char *__strncat_g (char *__dest, __const char __src[],
+				   size_t __n);
+
+__STRING_INLINE char *
+__strncat_g (char *__dest, __const char __src[], size_t __n)
+{
+  register char *__tmp = __dest;
+  register char __dummy;
+#ifdef __i686__
+  __asm__ __volatile__
+    ("repne; scasb\n"
+     "movl %4, %3\n\t"
+     "decl %1\n\t"
+     "1:\n\t"
+     "decl	%3\n\t"
+     "js	2f\n\t"
+     "movb	(%2),%b0\n\t"
+     "movsb\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	1b\n\t"
+     "decl	%1\n"
+     "2:\n\t"
+     "movb	$0,(%1)"
+     : "=&a" (__dummy), "=&D" (__tmp), "=&S" (__src), "=&c" (__n)
+     :  "g" (__n), "0" (0), "1" (__tmp), "2" (__src), "3" (0xffffffff)
+     : "memory", "cc");
+#else
+  --__tmp;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "cmpb	$0,1(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "decl	%3\n\t"
+     "js	3f\n\t"
+     "movb	(%2),%b0\n\t"
+     "leal	1(%2),%2\n\t"
+     "movb	%b0,(%1)\n\t"
+     "leal	1(%1),%1\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	2b\n\t"
+     "decl	%1\n"
+     "3:\n\t"
+     "movb	$0,(%1)"
+     : "=&q" (__dummy), "=&r" (__tmp), "=&r" (__src), "=&r" (__n)
+     : "1" (__tmp), "2" (__src), "3" (__n)
+     : "memory", "cc");
+#endif
+  return __dest;
+}
+
+
+/* Compare S1 and S2.  */
+#define _HAVE_STRING_ARCH_strcmp 1
+#define strcmp(s1, s2) \
+  (__extension__ (__builtin_constant_p (s1) && __builtin_constant_p (s2)      \
+		  && (sizeof ((s1)[0]) != 1 || strlen (s1) >= 4)	      \
+		  && (sizeof ((s2)[0]) != 1 || strlen (s2) >= 4)	      \
+		  ? memcmp ((__const char *) (s1), (__const char *) (s2),     \
+			    (strlen (s1) < strlen (s2)			      \
+			     ? strlen (s1) : strlen (s2)) + 1)		      \
+		  : (__builtin_constant_p (s1) && sizeof ((s1)[0]) == 1	      \
+		     && sizeof ((s2)[0]) == 1 && strlen (s1) < 4	      \
+		     ? (__builtin_constant_p (s2) && sizeof ((s2)[0]) == 1    \
+			? __strcmp_cc ((__const unsigned char *) (s1),	      \
+				       (__const unsigned char *) (s2),	      \
+				       strlen (s1))			      \
+			: __strcmp_cg ((__const unsigned char *) (s1),	      \
+				       (__const unsigned char *) (s2),	      \
+				       strlen (s1)))			      \
+		     : (__builtin_constant_p (s2) && sizeof ((s1)[0]) == 1    \
+			&& sizeof ((s2)[0]) == 1 && strlen (s2) < 4	      \
+			? (__builtin_constant_p (s1)			      \
+			   ? __strcmp_cc ((__const unsigned char *) (s1),     \
+					  (__const unsigned char *) (s2),     \
+					  strlen (s2))			      \
+			   : __strcmp_gc ((__const unsigned char *) (s1),     \
+					  (__const unsigned char *) (s2),     \
+					  strlen (s2)))			      \
+			: __strcmp_gg ((s1), (s2))))))
+
+#define __strcmp_cc(s1, s2, l) \
+  (__extension__ ({ register int __result = (s1)[0] - (s2)[0];		      \
+		    if (l > 0 && __result == 0)				      \
+		      {							      \
+			__result = (s1)[1] - (s2)[1];			      \
+			if (l > 1 && __result == 0)			      \
+			  {						      \
+			    __result = (s1)[2] - (s2)[2];		      \
+			    if (l > 2 && __result == 0)			      \
+			      __result = (s1)[3] - (s2)[3];		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+#define __strcmp_cg(s1, s2, l1) \
+  (__extension__ ({ __const unsigned char *__s2 = (s2);			      \
+		    register int __result = (s1)[0] - __s2[0];		      \
+		    if (l1 > 0 && __result == 0)			      \
+		      {							      \
+			__result = (s1)[1] - __s2[1];			      \
+			if (l1 > 1 && __result == 0)			      \
+			  {						      \
+			    __result = (s1)[2] - __s2[2];		      \
+			    if (l1 > 2 && __result == 0)		      \
+			      __result = (s1)[3] - __s2[3];		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+#define __strcmp_gc(s1, s2, l2) \
+  (__extension__ ({ __const unsigned char *__s1 = (s1);			      \
+		    register int __result = __s1[0] - (s2)[0];		      \
+		    if (l2 > 0 && __result == 0)			      \
+		      {							      \
+			__result = __s1[1] - (s2)[1];			      \
+			if (l2 > 1 && __result == 0)			      \
+			  {						      \
+			    __result = __s1[2] - (s2)[2];		      \
+			    if (l2 > 2 && __result == 0)		      \
+			      __result = __s1[3] - (s2)[3];		      \
+			  }						      \
+		      }							      \
+		    __result; }))
+
+__STRING_INLINE int __strcmp_gg (__const char *__s1, __const char *__s2);
+
+__STRING_INLINE int
+__strcmp_gg (__const char *__s1, __const char *__s2)
+{
+  register int __res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%1),%b0\n\t"
+     "leal	1(%1),%1\n\t"
+     "cmpb	%b0,(%2)\n\t"
+     "jne	2f\n\t"
+     "leal	1(%2),%2\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	1b\n\t"
+     "xorl	%0,%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "movl	$1,%0\n\t"
+     "jb	3f\n\t"
+     "negl	%0\n"
+     "3:"
+     : "=q" (__res), "=&r" (__s1), "=&r" (__s2)
+     : "1" (__s1), "2" (__s2),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s1),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s2)
+     : "cc");
+  return __res;
+}
+
+
+/* Compare N characters of S1 and S2.  */
+#define _HAVE_STRING_ARCH_strncmp 1
+#define strncmp(s1, s2, n) \
+  (__extension__ (__builtin_constant_p (s1) && strlen (s1) < ((size_t) (n))   \
+		  ? strcmp ((s1), (s2))					      \
+		  : (__builtin_constant_p (s2) && strlen (s2) < ((size_t) (n))\
+		     ? strcmp ((s1), (s2))				      \
+		     : __strncmp_g ((s1), (s2), (n)))))
+
+__STRING_INLINE int __strncmp_g (__const char *__s1, __const char *__s2,
+				 size_t __n);
+
+__STRING_INLINE int
+__strncmp_g (__const char *__s1, __const char *__s2, size_t __n)
+{
+  register int __res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "decl	%3\n\t"
+     "js	2f\n\t"
+     "movb	(%1),%b0\n\t"
+     "incl	%1\n\t"
+     "cmpb	%b0,(%2)\n\t"
+     "jne	3f\n\t"
+     "incl	%2\n\t"
+     "testb	%b0,%b0\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "xorl	%0,%0\n\t"
+     "jmp	4f\n"
+     "3:\n\t"
+     "movl	$1,%0\n\t"
+     "jb	4f\n\t"
+     "negl	%0\n"
+     "4:"
+     : "=q" (__res), "=&r" (__s1), "=&r" (__s2), "=&r" (__n)
+     : "1"  (__s1), "2"  (__s2),  "3" (__n),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s1),
+       "m" ( *(struct { __extension__ char __x[__n]; } *)__s2)
+     : "cc");
+  return __res;
+}
+
+
+/* Find the first occurrence of C in S.  */
+#define _HAVE_STRING_ARCH_strchr 1
+#define _USE_STRING_ARCH_strchr 1
+#define strchr(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? ((c) == '\0'					      \
+		     ? (char *) __rawmemchr ((s), (c))			      \
+		     : __strchr_c ((s), ((c) & 0xff) << 8))		      \
+		  : __strchr_g ((s), (c))))
+
+__STRING_INLINE char *__strchr_c (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchr_c (__const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "xorl	%0,%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strchr_g (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchr_g (__const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%%al,%%ah\n"
+     "1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "xorl	%0,%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+#define _HAVE_STRING_ARCH_strchrnul 1
+#define __strchrnul(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? ((c) == '\0'					      \
+		     ? (char *) __rawmemchr ((s), c)			      \
+		     : __strchrnul_c ((s), ((c) & 0xff) << 8))		      \
+		  : __strchrnul_g ((s), c)))
+
+__STRING_INLINE char *__strchrnul_c (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchrnul_c (__const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strchrnul_g (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strchrnul_g (__const char *__s, int __c)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%%al,%%ah\n"
+     "1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "leal	1(%0),%0\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+#ifdef __USE_GNU
+# define strchrnul(s, c) __strchrnul ((s), (c))
+#endif
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Find the first occurrence of C in S.  This is the BSD name.  */
+# define _HAVE_STRING_ARCH_index 1
+# define index(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? __strchr_c ((s), ((c) & 0xff) << 8)			      \
+		  : __strchr_g ((s), (c))))
+#endif
+
+
+/* Find the last occurrence of C in S.  */
+#define _HAVE_STRING_ARCH_strrchr 1
+#define strrchr(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? __strrchr_c ((s), ((c) & 0xff) << 8)		      \
+		  : __strrchr_g ((s), (c))))
+
+#ifdef __i686__
+__STRING_INLINE char *__strrchr_c (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_c (__const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%h2,%b2\n\t"
+     "cmove	%1,%0\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne 1b"
+     : "=d" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (1), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res - 1;
+}
+
+__STRING_INLINE char *__strrchr_g (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_g (__const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%b2,%h2\n"
+     "cld\n\t"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%h2,%b2\n\t"
+     "cmove	%1,%0\n\t"
+     "testb	%b2,%b2\n\t"
+     "jne 1b"
+     : "=d" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (1), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res - 1;
+}
+#else
+__STRING_INLINE char *__strrchr_c (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_c (__const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "jne	2f\n\t"
+     "leal	-1(%%esi),%0\n"
+     "2:\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne 1b"
+     : "=d" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (0), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strrchr_g (__const char *__s, int __c);
+
+__STRING_INLINE char *
+__strrchr_g (__const char *__s, int __c)
+{
+  register unsigned long int __d0, __d1;
+  register char *__res;
+  __asm__ __volatile__
+    ("movb	%%al,%%ah\n"
+     "cld\n\t"
+     "1:\n\t"
+     "lodsb\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "jne	2f\n\t"
+     "leal	-1(%%esi),%0\n"
+     "2:\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne 1b"
+     : "=r" (__res), "=&S" (__d0), "=&a" (__d1)
+     : "0" (0), "1" (__s), "2" (__c),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return __res;
+}
+#endif
+
+
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+/* Find the last occurrence of C in S.  This is the BSD name.  */
+# define _HAVE_STRING_ARCH_rindex 1
+# define rindex(s, c) \
+  (__extension__ (__builtin_constant_p (c)				      \
+		  ? __strrchr_c ((s), ((c) & 0xff) << 8)		      \
+		  : __strrchr_g ((s), (c))))
+#endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters not in REJECT.  */
+#define _HAVE_STRING_ARCH_strcspn 1
+#define strcspn(s, reject) \
+  (__extension__ (__builtin_constant_p (reject) && sizeof ((reject)[0]) == 1  \
+		  ? ((reject)[0] == '\0'				      \
+		     ? strlen (s)					      \
+		     : ((reject)[1] == '\0'				      \
+			? __strcspn_c1 ((s), (((reject)[0] << 8) & 0xff00))   \
+			: __strcspn_cg ((s), (reject), strlen (reject))))     \
+		  : __strcspn_g ((s), (reject))))
+
+__STRING_INLINE size_t __strcspn_c1 (__const char *__s, int __reject);
+
+#ifndef _FORCE_INLINES
+__STRING_INLINE size_t
+__strcspn_c1 (__const char *__s, int __reject)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%%al\n\t"
+     "leal	1(%0),%0\n\t"
+     "cmpb	%%ah,%%al\n\t"
+     "je	2f\n\t"
+     "testb	%%al,%%al\n\t"
+     "jne	1b\n"
+     "2:"
+     : "=r" (__res), "=&a" (__d0)
+     : "0" (__s), "1" (__reject),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return (__res - 1) - __s;
+}
+#endif
+
+__STRING_INLINE size_t __strcspn_cg (__const char *__s, __const char __reject[],
+				    size_t __reject_len);
+
+__STRING_INLINE size_t
+__strcspn_cg (__const char *__s, __const char __reject[], size_t __reject_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register __const char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%5,%%edi\n\t"
+     "movl	%6,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "d" (__reject), "g" (__reject_len)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+
+__STRING_INLINE size_t __strcspn_g (__const char *__s, __const char *__reject);
+#ifdef __PIC__
+
+__STRING_INLINE size_t
+__strcspn_g (__const char *__s, __const char *__reject)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register __const char *__res;
+  __asm__ __volatile__
+    ("pushl	%%ebx\n\t"
+     "movl	%4,%%edi\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%ebx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%4,%%edi\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n"
+     "2:\n\t"
+     "popl	%%ebx"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "r" (__reject), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+#else
+__STRING_INLINE size_t
+__strcspn_g (__const char *__s, __const char *__reject)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register __const char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%edx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2), "=&d" (__d3)
+     : "0" (__s), "1" (0), "2" (0xffffffff), "3" (__reject), "b" (__reject)
+     /* Clobber memory, otherwise GCC cannot handle this.  */
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+#endif
+
+
+/* Return the length of the initial segment of S which
+   consists entirely of characters in ACCEPT.  */
+#define _HAVE_STRING_ARCH_strspn 1
+#define strspn(s, accept) \
+  (__extension__ (__builtin_constant_p (accept) && sizeof ((accept)[0]) == 1  \
+		  ? ((accept)[0] == '\0'				      \
+		     ? ((void) (s), 0)					      \
+		     : ((accept)[1] == '\0'				      \
+			? __strspn_c1 ((s), (((accept)[0] << 8 ) & 0xff00))   \
+			: __strspn_cg ((s), (accept), strlen (accept))))      \
+		  : __strspn_g ((s), (accept))))
+
+#ifndef _FORCE_INLINES
+__STRING_INLINE size_t __strspn_c1 (__const char *__s, int __accept);
+
+__STRING_INLINE size_t
+__strspn_c1 (__const char *__s, int __accept)
+{
+  register unsigned long int __d0;
+  register char *__res;
+  /* Please note that __accept never can be '\0'.  */
+  __asm__ __volatile__
+    ("1:\n\t"
+     "movb	(%0),%b1\n\t"
+     "leal	1(%0),%0\n\t"
+     "cmpb	%h1,%b1\n\t"
+     "je	1b"
+     : "=r" (__res), "=&q" (__d0)
+     : "0" (__s), "1" (__accept),
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s)
+     : "cc");
+  return (__res - 1) - __s;
+}
+#endif
+
+__STRING_INLINE size_t __strspn_cg (__const char *__s, __const char __accept[],
+				    size_t __accept_len);
+
+__STRING_INLINE size_t
+__strspn_cg (__const char *__s, __const char __accept[], size_t __accept_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register __const char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%5,%%edi\n\t"
+     "movl	%6,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "je	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "g" (__accept), "g" (__accept_len),
+       /* Since we do not know how large the memory we access it, use a
+	  really large amount.  */
+       "m" ( *(struct { char __x[0xfffffff]; } *)__s),
+       "m" ( *(struct { __extension__ char __x[__accept_len]; } *)__accept)
+     : "cc");
+  return (__res - 1) - __s;
+}
+
+__STRING_INLINE size_t __strspn_g (__const char *__s, __const char *__accept);
+#ifdef __PIC__
+
+__STRING_INLINE size_t
+__strspn_g (__const char *__s, __const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register __const char *__res;
+  __asm__ __volatile__
+    ("pushl	%%ebx\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%ebx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "je	1b\n"
+     "2:\n\t"
+     "popl	%%ebx"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "d" (__accept), "0" (__s), "1" (0), "2" (0xffffffff), "3" (__accept)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+#else
+__STRING_INLINE size_t
+__strspn_g (__const char *__s, __const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register __const char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%edx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "je	1b\n"
+     "2:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2), "=&d" (__d3)
+     : "0" (__s), "1" (0), "2" (0xffffffff), "3" (__accept), "b" (__accept)
+     : "memory", "cc");
+  return (__res - 1) - __s;
+}
+#endif
+
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#define _HAVE_STRING_ARCH_strpbrk 1
+#define strpbrk(s, accept) \
+  (__extension__ (__builtin_constant_p (accept) && sizeof ((accept)[0]) == 1  \
+		  ? ((accept)[0] == '\0'				      \
+		     ? ((void) (s), (char *) 0)				      \
+		     : ((accept)[1] == '\0'				      \
+			? strchr ((s), (accept)[0])			      \
+			: __strpbrk_cg ((s), (accept), strlen (accept))))     \
+		  : __strpbrk_g ((s), (accept))))
+
+__STRING_INLINE char *__strpbrk_cg (__const char *__s, __const char __accept[],
+				    size_t __accept_len);
+
+__STRING_INLINE char *
+__strpbrk_cg (__const char *__s, __const char __accept[], size_t __accept_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%5,%%edi\n\t"
+     "movl	%6,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "xorl	%0,%0\n"
+     "3:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "0" (__s), "d" (__accept), "g" (__accept_len)
+     : "memory", "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strpbrk_g (__const char *__s, __const char *__accept);
+#ifdef __PIC__
+
+__STRING_INLINE char *
+__strpbrk_g (__const char *__s, __const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("pushl	%%ebx\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%ebx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "xorl	%0,%0\n"
+     "3:\n\t"
+     "popl	%%ebx"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&D" (__d2)
+     : "d" (__accept), "0" (__s), "1" (0), "2" (0xffffffff)
+     : "memory", "cc");
+  return __res;
+}
+#else
+__STRING_INLINE char *
+__strpbrk_g (__const char *__s, __const char *__accept)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register char *__res;
+  __asm__ __volatile__
+    ("movl	%%ebx,%%edi\n\t"
+     "cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "leal	-1(%%ecx),%%edx\n"
+     "1:\n\t"
+     "lodsb\n\t"
+     "testb	%%al,%%al\n\t"
+     "je	2f\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repne; scasb\n\t"
+     "jne	1b\n\t"
+     "decl	%0\n\t"
+     "jmp	3f\n"
+     "2:\n\t"
+     "xorl	%0,%0\n"
+     "3:"
+     : "=S" (__res), "=&a" (__d0), "=&c" (__d1), "=&d" (__d2), "=&D" (__d3)
+     : "0" (__s), "1" (0), "2" (0xffffffff), "b" (__accept)
+     : "memory", "cc");
+  return __res;
+}
+#endif
+
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+#define _HAVE_STRING_ARCH_strstr 1
+#define strstr(haystack, needle) \
+  (__extension__ (__builtin_constant_p (needle) && sizeof ((needle)[0]) == 1  \
+		  ? ((needle)[0] == '\0'				      \
+		     ? (haystack)					      \
+		     : ((needle)[1] == '\0'				      \
+			? strchr ((haystack), (needle)[0])		      \
+			: __strstr_cg ((haystack), (needle),		      \
+				       strlen (needle))))		      \
+		  : __strstr_g ((haystack), (needle))))
+
+/* Please note that this function need not handle NEEDLEs with a
+   length shorter than two.  */
+__STRING_INLINE char *__strstr_cg (__const char *__haystack, __const char __needle[],
+				   size_t __needle_len);
+
+__STRING_INLINE char *
+__strstr_cg (__const char *__haystack, __const char __needle[],
+	     size_t __needle_len)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n" \
+     "1:\n\t"
+     "movl	%6,%%edi\n\t"
+     "movl	%5,%%eax\n\t"
+     "movl	%4,%%ecx\n\t"
+     "repe; cmpsb\n\t"
+     "je	2f\n\t"
+     "cmpb	$0,-1(%%esi)\n\t"
+     "leal	1(%%eax),%5\n\t"
+     "jne	1b\n\t"
+     "xorl	%%eax,%%eax\n"
+     "2:"
+     : "=&a" (__res), "=&S" (__d0), "=&D" (__d1), "=&c" (__d2)
+     : "g" (__needle_len), "1" (__haystack), "d" (__needle)
+     : "memory", "cc");
+  return __res;
+}
+
+__STRING_INLINE char *__strstr_g (__const char *__haystack, __const char *__needle);
+#ifdef __PIC__
+
+__STRING_INLINE char *
+__strstr_g (__const char *__haystack, __const char *__needle)
+{
+  register unsigned long int __d0, __d1, __d2;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "pushl	%%ebx\n\t"
+     "decl	%%ecx\n\t"	/* NOTE! This also sets Z if searchstring='' */
+     "movl	%%ecx,%%ebx\n"
+     "1:\n\t"
+     "movl	%%edx,%%edi\n\t"
+     "movl	%%esi,%%eax\n\t"
+     "movl	%%ebx,%%ecx\n\t"
+     "repe; cmpsb\n\t"
+     "je	2f\n\t"		/* also works for empty string, see above */
+     "cmpb	$0,-1(%%esi)\n\t"
+     "leal	1(%%eax),%%esi\n\t"
+     "jne	1b\n\t"
+     "xorl	%%eax,%%eax\n"
+     "2:\n\t"
+     "popl	%%ebx"
+     : "=&a" (__res), "=&c" (__d0), "=&S" (__d1), "=&D" (__d2)
+     : "0" (0), "1" (0xffffffff), "2" (__haystack), "3" (__needle),
+       "d" (__needle)
+     : "memory", "cc");
+  return __res;
+}
+#else
+__STRING_INLINE char *
+__strstr_g (__const char *__haystack, __const char *__needle)
+{
+  register unsigned long int __d0, __d1, __d2, __d3;
+  register char *__res;
+  __asm__ __volatile__
+    ("cld\n\t"
+     "repne; scasb\n\t"
+     "notl	%%ecx\n\t"
+     "decl	%%ecx\n\t"	/* NOTE! This also sets Z if searchstring='' */
+     "movl	%%ecx,%%edx\n"
+     "1:\n\t"
+     "movl	%%ebx,%%edi\n\t"
+     "movl	%%esi,%%eax\n\t"
+     "movl	%%edx,%%ecx\n\t"
+     "repe; cmpsb\n\t"
+     "je	2f\n\t"		/* also works for empty string, see above */
+     "cmpb	$0,-1(%%esi)\n\t"
+     "leal	1(%%eax),%%esi\n\t"
+     "jne	1b\n\t"
+     "xorl	%%eax,%%eax\n"
+     "2:"
+     : "=&a" (__res), "=&c" (__d0), "=&S" (__d1), "=&D" (__d2), "=&d" (__d3)
+     : "0" (0), "1" (0xffffffff), "2" (__haystack), "3" (__needle),
+       "b" (__needle)
+     : "memory", "cc");
+  return __res;
+}
+#endif
+
+
+/* Bit find functions.  We define only the i686 version since for the other
+   processors gcc generates good code.  */
+#if defined __USE_BSD || defined __USE_XOPEN_EXTENDED
+# ifdef __i686__
+#  define _HAVE_STRING_ARCH_ffs 1
+#  define ffs(word) (__builtin_constant_p (word)			      \
+		     ? __builtin_ffs (word)				      \
+		     : ({ int __cnt, __tmp;				      \
+			  __asm__ __volatile__				      \
+			    ("bsfl %2,%0\n\t"				      \
+			     "cmovel %1,%0"				      \
+			     : "=&r" (__cnt), "=r" (__tmp)		      \
+			     : "rm" (word), "1" (-1));			      \
+			  __cnt + 1; }))
+
+#  ifndef ffsl
+#   define ffsl(word) ffs(word)
+#  endif
+# endif	/* i686 */
+#endif	/* BSD || X/Open */
+
+#ifndef _FORCE_INLINES
+# undef __STRING_INLINE
+#endif
+
+#endif	/* wordsize == 32 && use string inlines && GNU CC */
Index: git/sysdeps/x86_64/fpu/bits/mathinline.h
===================================================================
--- git.orig/sysdeps/x86_64/fpu/bits/mathinline.h
+++ git/sysdeps/x86_64/fpu/bits/mathinline.h
@@ -1,7 +1,9 @@
-/* Inline math functions for x86-64.
-   Copyright (C) 2002, 2003, 2004, 2007, 2009 Free Software Foundation, Inc.
+/* Inline math functions for i387/x86-64.
+   Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2006,2007,2009,
+   2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
-   Contributed by Andreas Jaeger <aj@suse.de>, 2002.
+   Contributed by John C. Bowman <bowman@math.ualberta.ca>, 1995. (i387)
+   Contributed by Andreas Jaeger <aj@suse.de>, 2002. (x86-64)
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -32,7 +34,98 @@
 
 
 #if defined __USE_ISOC99 && defined __GNUC__ && __GNUC__ >= 2
+/* GCC 2.97 and up have builtins that actually can be used.  */
+# if __WORDSIZE == 32 && !__GNUC_PREREQ (2,97)
+/* ISO C99 defines some macros to perform unordered comparisons.  The
+   ix87 FPU supports this with special opcodes and we should use them.
+   These must not be inline functions since we have to be able to handle
+   all floating-point types.  */
+#  undef isgreater
+#  undef isgreaterequal
+#  undef isless
+#  undef islessequal
+#  undef islessgreater
+#  undef isunordered
+#  ifdef __i686__
+/* For the PentiumPro and more recent processors we can provide
+   better code.  */
+#   define isgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+#   define isgreaterequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
 
+#   define isless(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; seta %%al"			      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
+	__result; })
+
+#   define islessequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setae %%al"			      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st");	      \
+	__result; })
+
+#   define islessgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setne %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+
+#   define isunordered(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucomip %%st(1), %%st; setp %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st");	      \
+	__result; })
+#  else
+/* This is the dumb, portable code for i386 and above.  */
+#   define isgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define isgreaterequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define isless(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define islessequal(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (x), "t" (y) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define islessgreater(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; testb $0x44, %%ah; setz %%al"	      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+
+#   define isunordered(x, y) \
+     ({ register char __result;						      \
+	__asm__ ("fucompp; fnstsw; sahf; setp %%al"			      \
+		 : "=a" (__result) : "u" (y), "t" (x) : "cc", "st", "st(1)"); \
+	__result; })
+#  endif /* __i686__ */
+# endif	/* __WORDSIZE == 32 && GCC 2.97 */
+
+/* The gcc, version 2.7 or below, has problems with all this inlining
+   code.  So disable it for this version of the compiler.  */
+# if __GNUC_PREREQ (2, 8)
 /* Test for negative number.  Used in the signbit() macro.  */
 __MATH_INLINE int
 __NTH (__signbitf (float __x))
@@ -64,4 +157,630 @@ __NTH (__signbitl (long double __x))
   __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
   return (__u.__i[2] & 0x8000) != 0;
 }
+# endif
+#endif
+
+
+/* The gcc, version 2.7 or below, has problems with all this inlining
+   code.  So disable it for this version of the compiler.  */
+#if __WORDSIZE == 32 && __GNUC_PREREQ (2, 8)
+
+#if ((!defined __NO_MATH_INLINES || defined __LIBC_INTERNAL_MATH_INLINES) \
+     && defined __OPTIMIZE__)
+
+/* The inline functions do not set errno or raise necessarily the
+   correct exceptions.  */
+# undef math_errhandling
+
+/* A macro to define float, double, and long double versions of various
+   math functions for the ix87 FPU.  FUNC is the function name (which will
+   be suffixed with f and l for the float and long double version,
+   respectively).  OP is the name of the FPU operation.
+   We define two sets of macros.  The set with the additional NP
+   doesn't add a prototype declaration.  */
+
+#if defined __USE_MISC || defined __USE_ISOC99
+# define __inline_mathop(func, op) \
+  __inline_mathop_ (double, func, op)					      \
+  __inline_mathop_ (float, __CONCAT(func,f), op)			      \
+  __inline_mathop_ (long double, __CONCAT(func,l), op)
+# define __inline_mathopNP(func, op) \
+  __inline_mathopNP_ (double, func, op)					      \
+  __inline_mathopNP_ (float, __CONCAT(func,f), op)			      \
+  __inline_mathopNP_ (long double, __CONCAT(func,l), op)
+#else
+# define __inline_mathop(func, op) \
+  __inline_mathop_ (double, func, op)
+# define __inline_mathopNP(func, op) \
+  __inline_mathopNP_ (double, func, op)
+#endif
+
+#define __inline_mathop_(float_type, func, op) \
+  __inline_mathop_decl_ (float_type, func, op, "0" (__x))
+#define __inline_mathopNP_(float_type, func, op) \
+  __inline_mathop_declNP_ (float_type, func, op, "0" (__x))
+
+
+#if defined __USE_MISC || defined __USE_ISOC99
+# define __inline_mathop_decl(func, op, params...) \
+  __inline_mathop_decl_ (double, func, op, params)			      \
+  __inline_mathop_decl_ (float, __CONCAT(func,f), op, params)		      \
+  __inline_mathop_decl_ (long double, __CONCAT(func,l), op, params)
+# define __inline_mathop_declNP(func, op, params...) \
+  __inline_mathop_declNP_ (double, func, op, params)			      \
+  __inline_mathop_declNP_ (float, __CONCAT(func,f), op, params)		      \
+  __inline_mathop_declNP_ (long double, __CONCAT(func,l), op, params)
+#else
+# define __inline_mathop_decl(func, op, params...) \
+  __inline_mathop_decl_ (double, func, op, params)
+# define __inline_mathop_declNP(func, op, params...) \
+  __inline_mathop_declNP_ (double, func, op, params)
+#endif
+
+#define __inline_mathop_decl_(float_type, func, op, params...) \
+  __MATH_INLINE float_type func (float_type) __THROW;			      \
+  __inline_mathop_declNP_ (float_type, func, op, params)
+
+#define __inline_mathop_declNP_(float_type, func, op, params...) \
+  __MATH_INLINE float_type __NTH (func (float_type __x))		      \
+  {									      \
+    register float_type __result;					      \
+    __asm __volatile__ (op : "=t" (__result) : params);			      \
+    return __result;							      \
+  }
+
+
+#if defined __USE_MISC || defined __USE_ISOC99
+# define __inline_mathcode(func, arg, code) \
+  __inline_mathcode_ (double, func, arg, code)				      \
+  __inline_mathcode_ (float, __CONCAT(func,f), arg, code)		      \
+  __inline_mathcode_ (long double, __CONCAT(func,l), arg, code)
+# define __inline_mathcodeNP(func, arg, code) \
+  __inline_mathcodeNP_ (double, func, arg, code)			      \
+  __inline_mathcodeNP_ (float, __CONCAT(func,f), arg, code)		      \
+  __inline_mathcodeNP_ (long double, __CONCAT(func,l), arg, code)
+# define __inline_mathcode2(func, arg1, arg2, code) \
+  __inline_mathcode2_ (double, func, arg1, arg2, code)			      \
+  __inline_mathcode2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
+  __inline_mathcode2_ (long double, __CONCAT(func,l), arg1, arg2, code)
+# define __inline_mathcodeNP2(func, arg1, arg2, code) \
+  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)		      \
+  __inline_mathcodeNP2_ (float, __CONCAT(func,f), arg1, arg2, code)	      \
+  __inline_mathcodeNP2_ (long double, __CONCAT(func,l), arg1, arg2, code)
+# define __inline_mathcode3(func, arg1, arg2, arg3, code) \
+  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)		      \
+  __inline_mathcode3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)	      \
+  __inline_mathcode3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
+# define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
+  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)		      \
+  __inline_mathcodeNP3_ (float, __CONCAT(func,f), arg1, arg2, arg3, code)     \
+  __inline_mathcodeNP3_ (long double, __CONCAT(func,l), arg1, arg2, arg3, code)
+#else
+# define __inline_mathcode(func, arg, code) \
+  __inline_mathcode_ (double, func, (arg), code)
+# define __inline_mathcodeNP(func, arg, code) \
+  __inline_mathcodeNP_ (double, func, (arg), code)
+# define __inline_mathcode2(func, arg1, arg2, code) \
+  __inline_mathcode2_ (double, func, arg1, arg2, code)
+# define __inline_mathcodeNP2(func, arg1, arg2, code) \
+  __inline_mathcodeNP2_ (double, func, arg1, arg2, code)
+# define __inline_mathcode3(func, arg1, arg2, arg3, code) \
+  __inline_mathcode3_ (double, func, arg1, arg2, arg3, code)
+# define __inline_mathcodeNP3(func, arg1, arg2, arg3, code) \
+  __inline_mathcodeNP3_ (double, func, arg1, arg2, arg3, code)
+#endif
+
+#define __inline_mathcode_(float_type, func, arg, code) \
+  __MATH_INLINE float_type func (float_type) __THROW;			      \
+  __inline_mathcodeNP_(float_type, func, arg, code)
+
+#define __inline_mathcodeNP_(float_type, func, arg, code) \
+  __MATH_INLINE float_type __NTH (func (float_type arg))		      \
+  {									      \
+    code;								      \
+  }
+
+
+#define __inline_mathcode2_(float_type, func, arg1, arg2, code) \
+  __MATH_INLINE float_type func (float_type, float_type) __THROW;	      \
+  __inline_mathcodeNP2_ (float_type, func, arg1, arg2, code)
+
+#define __inline_mathcodeNP2_(float_type, func, arg1, arg2, code) \
+  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2))    \
+  {									      \
+    code;								      \
+  }
+
+#define __inline_mathcode3_(float_type, func, arg1, arg2, arg3, code) \
+  __MATH_INLINE float_type func (float_type, float_type, float_type) __THROW; \
+  __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code)
+
+#define __inline_mathcodeNP3_(float_type, func, arg1, arg2, arg3, code) \
+  __MATH_INLINE float_type __NTH (func (float_type arg1, float_type arg2,     \
+					float_type arg3))		      \
+  {									      \
+    code;								      \
+  }
+#endif
+
+
+#if !defined __NO_MATH_INLINES && defined __OPTIMIZE__
+/* Miscellaneous functions */
+
+__inline_mathcode (__sgn, __x, \
+  return __x == 0.0 ? 0.0 : (__x > 0.0 ? 1.0 : -1.0))
+
+/* __FAST_MATH__ is defined by gcc -ffast-math.  */
+#ifdef __FAST_MATH__
+__inline_mathcode (__pow2, __x, \
+  register long double __value;						      \
+  register long double __exponent;					      \
+  __extension__ long long int __p = (long long int) __x;		      \
+  if (__x == (long double) __p)						      \
+    {									      \
+      __asm __volatile__						      \
+	("fscale"							      \
+	 : "=t" (__value) : "0" (1.0), "u" (__x));			      \
+      return __value;							      \
+    }									      \
+  __asm __volatile__							      \
+    ("fld	%%st(0)\n\t"						      \
+     "frndint			# int(x)\n\t"				      \
+     "fxch\n\t"								      \
+     "fsub	%%st(1)		# fract(x)\n\t"				      \
+     "f2xm1			# 2^(fract(x)) - 1\n\t"			      \
+     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+  __value += 1.0;							      \
+  __asm __volatile__							      \
+    ("fscale"								      \
+     : "=t" (__value) : "0" (__value), "u" (__exponent));		      \
+  return __value)
+
+# ifdef __USE_GNU
+#  define __sincos_code \
+  register long double __cosr;						      \
+  register long double __sinr;						      \
+  __asm __volatile__							      \
+    ("fsincos\n\t"							      \
+     "fnstsw	%%ax\n\t"						      \
+     "testl	$0x400, %%eax\n\t"					      \
+     "jz	1f\n\t"							      \
+     "fldpi\n\t"							      \
+     "fadd	%%st(0)\n\t"						      \
+     "fxch	%%st(1)\n\t"						      \
+     "2: fprem1\n\t"							      \
+     "fnstsw	%%ax\n\t"						      \
+     "testl	$0x400, %%eax\n\t"					      \
+     "jnz	2b\n\t"							      \
+     "fstp	%%st(1)\n\t"						      \
+     "fsincos\n\t"							      \
+     "1:"								      \
+     : "=t" (__cosr), "=u" (__sinr) : "0" (__x));			      \
+  *__sinx = __sinr;							      \
+  *__cosx = __cosr
+
+__MATH_INLINE void
+__NTH (__sincos (double __x, double *__sinx, double *__cosx))
+{
+  __sincos_code;
+}
+
+__MATH_INLINE void
+__NTH (__sincosf (float __x, float *__sinx, float *__cosx))
+{
+  __sincos_code;
+}
+
+__MATH_INLINE void
+__NTH (__sincosl (long double __x, long double *__sinx, long double *__cosx))
+{
+  __sincos_code;
+}
+# endif
+
+
+/* Optimized inline implementation, sometimes with reduced precision
+   and/or argument range.  */
+
+# if __GNUC_PREREQ (3, 5)
+#  define __expm1_code \
+  register long double __temp;						      \
+  __temp = __builtin_expm1l (__x);					      \
+  return __temp ? __temp : __x
+# else
+#  define __expm1_code \
+  register long double __value;						      \
+  register long double __exponent;					      \
+  register long double __temp;						      \
+  __asm __volatile__							      \
+    ("fldl2e			# e^x - 1 = 2^(x * log2(e)) - 1\n\t"	      \
+     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
+     "fst	%%st(1)\n\t"						      \
+     "frndint			# int(x * log2(e))\n\t"			      \
+     "fxch\n\t"								      \
+     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
+     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
+     "fscale			# 2^(x * log2(e)) - 2^(int(x * log2(e)))\n\t" \
+     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+  __asm __volatile__							      \
+    ("fscale			# 2^int(x * log2(e))\n\t"		      \
+     : "=t" (__temp) : "0" (1.0), "u" (__exponent));			      \
+  __temp -= 1.0;							      \
+  __temp += __value;							      \
+  return __temp ? __temp : __x
+# endif
+__inline_mathcodeNP_ (long double, __expm1l, __x, __expm1_code)
+
+# if __GNUC_PREREQ (3, 4)
+__inline_mathcodeNP_ (long double, __expl, __x, return __builtin_expl (__x))
+# else
+#  define __exp_code \
+  register long double __value;						      \
+  register long double __exponent;					      \
+  __asm __volatile__							      \
+    ("fldl2e			# e^x = 2^(x * log2(e))\n\t"		      \
+     "fmul	%%st(1)		# x * log2(e)\n\t"			      \
+     "fst	%%st(1)\n\t"						      \
+     "frndint			# int(x * log2(e))\n\t"			      \
+     "fxch\n\t"								      \
+     "fsub	%%st(1)		# fract(x * log2(e))\n\t"		      \
+     "f2xm1			# 2^(fract(x * log2(e))) - 1\n\t"	      \
+     : "=t" (__value), "=u" (__exponent) : "0" (__x));			      \
+  __value += 1.0;							      \
+  __asm __volatile__							      \
+    ("fscale"								      \
+     : "=t" (__value) : "0" (__value), "u" (__exponent));		      \
+  return __value
+__inline_mathcodeNP (exp, __x, __exp_code)
+__inline_mathcodeNP_ (long double, __expl, __x, __exp_code)
+# endif
+
+
+# if !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP (tan, __x, \
+  register long double __value;						      \
+  register long double __value2 __attribute__ ((__unused__));		      \
+  __asm __volatile__							      \
+    ("fptan"								      \
+     : "=t" (__value2), "=u" (__value) : "0" (__x));			      \
+  return __value)
+# endif
+#endif /* __FAST_MATH__ */
+
+
+#if __GNUC_PREREQ (3, 4)
+__inline_mathcodeNP2_ (long double, __atan2l, __y, __x,
+		       return __builtin_atan2l (__y, __x))
+#else
+# define __atan2_code \
+  register long double __value;						      \
+  __asm __volatile__							      \
+    ("fpatan"								      \
+     : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");		      \
+  return __value
+# ifdef __FAST_MATH__
+__inline_mathcodeNP2 (atan2, __y, __x, __atan2_code)
+# endif
+__inline_mathcodeNP2_ (long double, __atan2l, __y, __x, __atan2_code)
+#endif
+
+
+#if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP2 (fmod, __x, __y, \
+  register long double __value;						      \
+  __asm __volatile__							      \
+    ("1:	fprem\n\t"						      \
+     "fnstsw	%%ax\n\t"						      \
+     "sahf\n\t"								      \
+     "jp	1b"							      \
+     : "=t" (__value) : "0" (__x), "u" (__y) : "ax", "cc");		      \
+  return __value)
+#endif
+
+
+#ifdef __FAST_MATH__
+# if !__GNUC_PREREQ (3,3)
+__inline_mathopNP (sqrt, "fsqrt")
+__inline_mathopNP_ (long double, __sqrtl, "fsqrt")
+#  define __libc_sqrtl(n) __sqrtl (n)
+# else
+#  define __libc_sqrtl(n) __builtin_sqrtl (n)
+# endif
+#endif
+
+#if __GNUC_PREREQ (2, 8)
+__inline_mathcodeNP_ (double, fabs, __x, return __builtin_fabs (__x))
+# if defined __USE_MISC || defined __USE_ISOC99
+__inline_mathcodeNP_ (float, fabsf, __x, return __builtin_fabsf (__x))
+__inline_mathcodeNP_ (long double, fabsl, __x, return __builtin_fabsl (__x))
+# endif
+__inline_mathcodeNP_ (long double, __fabsl, __x, return __builtin_fabsl (__x))
+#else
+__inline_mathop (fabs, "fabs")
+__inline_mathop_ (long double, __fabsl, "fabs")
+#endif
+
+#ifdef __FAST_MATH__
+# if !__GNUC_PREREQ (3, 4)
+/* The argument range of this inline version is reduced.  */
+__inline_mathopNP (sin, "fsin")
+/* The argument range of this inline version is reduced.  */
+__inline_mathopNP (cos, "fcos")
+
+__inline_mathop_declNP (log, "fldln2; fxch; fyl2x", "0" (__x) : "st(1)")
+# endif
+
+# if !__GNUC_PREREQ (3, 5)
+__inline_mathop_declNP (log10, "fldlg2; fxch; fyl2x", "0" (__x) : "st(1)")
+
+__inline_mathcodeNP (asin, __x, return __atan2l (__x, __libc_sqrtl (1.0 - __x * __x)))
+__inline_mathcodeNP (acos, __x, return __atan2l (__libc_sqrtl (1.0 - __x * __x), __x))
+# endif
+
+# if !__GNUC_PREREQ (3, 4)
+__inline_mathop_declNP (atan, "fld1; fpatan", "0" (__x) : "st(1)")
+# endif
+#endif /* __FAST_MATH__ */
+
+__inline_mathcode_ (long double, __sgn1l, __x, \
+  __extension__ union { long double __xld; unsigned int __xi[3]; } __n =      \
+    { __xld: __x };							      \
+  __n.__xi[2] = (__n.__xi[2] & 0x8000) | 0x3fff;			      \
+  __n.__xi[1] = 0x80000000;						      \
+  __n.__xi[0] = 0;							      \
+  return __n.__xld)
+
+
+#ifdef __FAST_MATH__
+/* The argument range of the inline version of sinhl is slightly reduced.  */
+__inline_mathcodeNP (sinh, __x, \
+  register long double __exm1 = __expm1l (__fabsl (__x));		      \
+  return 0.5 * (__exm1 / (__exm1 + 1.0) + __exm1) * __sgn1l (__x))
+
+__inline_mathcodeNP (cosh, __x, \
+  register long double __ex = __expl (__x);				      \
+  return 0.5 * (__ex + 1.0 / __ex))
+
+__inline_mathcodeNP (tanh, __x, \
+  register long double __exm1 = __expm1l (-__fabsl (__x + __x));	      \
+  return __exm1 / (__exm1 + 2.0) * __sgn1l (-__x))
+#endif
+
+__inline_mathcodeNP (floor, __x, \
+  register long double __value;						      \
+  register int __ignore;						      \
+  unsigned short int __cw;						      \
+  unsigned short int __cwtmp;						      \
+  __asm __volatile ("fnstcw %3\n\t"					      \
+		    "movzwl %3, %1\n\t"					      \
+		    "andl $0xf3ff, %1\n\t"				      \
+		    "orl $0x0400, %1\n\t"	/* rounding down */	      \
+		    "movw %w1, %2\n\t"					      \
+		    "fldcw %2\n\t"					      \
+		    "frndint\n\t"					      \
+		    "fldcw %3"						      \
+		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
+		      "=m" (__cw)					      \
+		    : "0" (__x));					      \
+  return __value)
+
+__inline_mathcodeNP (ceil, __x, \
+  register long double __value;						      \
+  register int __ignore;						      \
+  unsigned short int __cw;						      \
+  unsigned short int __cwtmp;						      \
+  __asm __volatile ("fnstcw %3\n\t"					      \
+		    "movzwl %3, %1\n\t"					      \
+		    "andl $0xf3ff, %1\n\t"				      \
+		    "orl $0x0800, %1\n\t"	/* rounding up */	      \
+		    "movw %w1, %2\n\t"					      \
+		    "fldcw %2\n\t"					      \
+		    "frndint\n\t"					      \
+		    "fldcw %3"						      \
+		    : "=t" (__value), "=&q" (__ignore), "=m" (__cwtmp),	      \
+		      "=m" (__cw)					      \
+		    : "0" (__x));					      \
+  return __value)
+
+#ifdef __FAST_MATH__
+# define __ldexp_code \
+  register long double __value;						      \
+  __asm __volatile__							      \
+    ("fscale"								      \
+     : "=t" (__value) : "0" (__x), "u" ((long double) __y));		      \
+  return __value
+
+__MATH_INLINE double
+__NTH (ldexp (double __x, int __y))
+{
+  __ldexp_code;
+}
+#endif
+
+
+/* Optimized versions for some non-standardized functions.  */
+#if defined __USE_ISOC99 || defined __USE_MISC
+
+# ifdef __FAST_MATH__
+__inline_mathcodeNP (expm1, __x, __expm1_code)
+
+/* We cannot rely on M_SQRT being defined.  So we do it for ourself
+   here.  */
+#  define __M_SQRT2	1.41421356237309504880L	/* sqrt(2) */
+
+#  if !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP (log1p, __x, \
+  register long double __value;						      \
+  if (__fabsl (__x) >= 1.0 - 0.5 * __M_SQRT2)				      \
+    __value = logl (1.0 + __x);						      \
+  else									      \
+    __asm __volatile__							      \
+      ("fldln2\n\t"							      \
+       "fxch\n\t"							      \
+       "fyl2xp1"							      \
+       : "=t" (__value) : "0" (__x) : "st(1)");				      \
+  return __value)
+#  endif
+
+
+/* The argument range of the inline version of asinhl is slightly reduced.  */
+__inline_mathcodeNP (asinh, __x, \
+  register long double  __y = __fabsl (__x);				      \
+  return (log1pl (__y * __y / (__libc_sqrtl (__y * __y + 1.0) + 1.0) + __y)   \
+	  * __sgn1l (__x)))
+
+__inline_mathcodeNP (acosh, __x, \
+  return logl (__x + __libc_sqrtl (__x - 1.0) * __libc_sqrtl (__x + 1.0)))
+
+__inline_mathcodeNP (atanh, __x, \
+  register long double __y = __fabsl (__x);				      \
+  return -0.5 * log1pl (-(__y + __y) / (1.0 + __y)) * __sgn1l (__x))
+
+/* The argument range of the inline version of hypotl is slightly reduced.  */
+__inline_mathcodeNP2 (hypot, __x, __y,
+		      return __libc_sqrtl (__x * __x + __y * __y))
+
+#  if !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP(logb, __x, \
+  register long double __value;						      \
+  register long double __junk;						      \
+  __asm __volatile__							      \
+    ("fxtract\n\t"							      \
+     : "=t" (__junk), "=u" (__value) : "0" (__x));			      \
+  return __value)
+#  endif
+
+# endif
 #endif
+
+#ifdef __USE_ISOC99
+# ifdef __FAST_MATH__
+
+#  if !__GNUC_PREREQ (3, 5)
+__inline_mathop_declNP (log2, "fld1; fxch; fyl2x", "0" (__x) : "st(1)")
+#  endif
+
+__MATH_INLINE float
+__NTH (ldexpf (float __x, int __y))
+{
+  __ldexp_code;
+}
+
+__MATH_INLINE long double
+__NTH (ldexpl (long double __x, int __y))
+{
+  __ldexp_code;
+}
+
+__inline_mathopNP (rint, "frndint")
+# endif /* __FAST_MATH__ */
+
+# define __lrint_code \
+  long int __lrintres;							      \
+  __asm__ __volatile__							      \
+    ("fistpl %0"							      \
+     : "=m" (__lrintres) : "t" (__x) : "st");				      \
+  return __lrintres
+__MATH_INLINE long int
+__NTH (lrintf (float __x))
+{
+  __lrint_code;
+}
+__MATH_INLINE long int
+__NTH (lrint (double __x))
+{
+  __lrint_code;
+}
+__MATH_INLINE long int
+__NTH (lrintl (long double __x))
+{
+  __lrint_code;
+}
+# undef __lrint_code
+
+# define __llrint_code \
+  long long int __llrintres;						      \
+  __asm__ __volatile__							      \
+    ("fistpll %0"							      \
+     : "=m" (__llrintres) : "t" (__x) : "st");				      \
+  return __llrintres
+__MATH_INLINE long long int
+__NTH (llrintf (float __x))
+{
+  __llrint_code;
+}
+__MATH_INLINE long long int
+__NTH (llrint (double __x))
+{
+  __llrint_code;
+}
+__MATH_INLINE long long int
+__NTH (llrintl (long double __x))
+{
+  __llrint_code;
+}
+# undef __llrint_code
+
+#endif
+
+
+#ifdef __USE_MISC
+
+# if defined __FAST_MATH__ && !__GNUC_PREREQ (3, 5)
+__inline_mathcodeNP2 (drem, __x, __y, \
+  register double __value;						      \
+  register int __clobbered;						      \
+  __asm __volatile__							      \
+    ("1:	fprem1\n\t"						      \
+     "fstsw	%%ax\n\t"						      \
+     "sahf\n\t"								      \
+     "jp	1b"							      \
+     : "=t" (__value), "=&a" (__clobbered) : "0" (__x), "u" (__y) : "cc");    \
+  return __value)
+# endif
+
+
+/* This function is used in the `isfinite' macro.  */
+__MATH_INLINE int
+__NTH (__finite (double __x))
+{
+  return (__extension__
+	  (((((union { double __d; int __i[2]; }) {__d: __x}).__i[1]
+	     | 0x800fffffu) + 1) >> 31));
+}
+
+/* Miscellaneous functions */
+# ifdef __FAST_MATH__
+__inline_mathcode (__coshm1, __x, \
+  register long double __exm1 = __expm1l (__fabsl (__x));		      \
+  return 0.5 * (__exm1 / (__exm1 + 1.0)) * __exm1)
+
+__inline_mathcode (__acosh1p, __x, \
+  return log1pl (__x + __libc_sqrtl (__x) * __libc_sqrtl (__x + 2.0)))
+
+# endif /* __FAST_MATH__ */
+#endif /* __USE_MISC  */
+
+/* Undefine some of the large macros which are not used anymore.  */
+#undef __atan2_code
+#ifdef __FAST_MATH__
+# undef __expm1_code
+# undef __exp_code
+# undef __sincos_code
+#endif /* __FAST_MATH__ */
+
+#endif /* __NO_MATH_INLINES  */
+
+
+/* This code is used internally in the GNU libc.  */
+#ifdef __LIBC_INTERNAL_MATH_INLINES
+__inline_mathop (__ieee754_sqrt, "fsqrt")
+__inline_mathcode2 (__ieee754_atan2, __y, __x,
+		    register long double __value;
+		    __asm __volatile__ ("fpatan\n\t"
+					: "=t" (__value)
+					: "0" (__x), "u" (__y) : "st(1)");
+		    return __value;)
+#endif
+
+#endif /* WORDSIZE == 32 && __GNUC__  */
Index: git/sysdeps/x86_64/fpu_control.h
===================================================================
--- git.orig/sysdeps/x86_64/fpu_control.h
+++ git/sysdeps/x86_64/fpu_control.h
@@ -1,5 +1,5 @@
-/* FPU control word bits.  x86-64 version.
-   Copyright (C) 1993,1995,1996,1997,1998,2000,2001,2002 Free Software Foundation, Inc.
+/* FPU control word bits.  i387/x86_64 version.
+   Copyright (C) 1993,1995-1998,2000,2001,2002,2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Olaf Flebbe.
 
@@ -21,9 +21,6 @@
 #ifndef _FPU_CONTROL_H
 #define _FPU_CONTROL_H	1
 
-/* Note that this file sets on x86-64 only the x87 FPU, it does not
-   touch the SSE unit.  */
-
 /* Here is the dirty part. Set up your 387 through the control word
  * (cw) register.
  *
@@ -91,9 +88,13 @@
 /* Type of the control word.  */
 typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
 
-/* Macros for accessing the hardware control word.  */
-#define _FPU_GETCW(cw) __asm__ ("fnstcw %0" : "=m" (*&cw))
-#define _FPU_SETCW(cw) __asm__ ("fldcw %0" : : "m" (*&cw))
+/* Macros for accessing the hardware control word.
+
+   Note that the use of these macros is no sufficient anymore with
+   recent hardware.  Some floating point operations are executed in
+   the SSE/SSE2 engines which have their own control and status register.  */
+#define _FPU_GETCW(cw) __asm__ __volatile__ ("fnstcw %0" : "=m" (*&cw))
+#define _FPU_SETCW(cw) __asm__ __volatile__ ("fldcw %0" : : "m" (*&cw))
 
 /* Default control word set at startup.  */
 extern fpu_control_t __fpu_control;
